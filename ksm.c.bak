#include "types.h"
#include "defs.h"
#include "spinlock.h"

// typedef uint hash_t;

#define NAME_MAX 255
#define NRKSM    1024   // number of kaust shared memory

//#define IS_CREATE(flag) (flag & KSM_CREATE)
//#define IS_OPEN(flag)   (flag & KSM_OPEN)

// Pick either implementation below. Both the singly list and the hash tree is fine.

// KSM handler type
// Here, use a singly list to manage all the ksm handlers, simple but might be slower
struct ksmhd_t {
//  struct spinlock lock;
//  hash_t hash;   // Each ksm handler is associated with a hash value
  char ksm_name[NAME_MAX+1];  // KSM name
  struct ksminfo_t* ksminfo;  // KSM info structure
  struct ksmhd_t* next;
};

struct {
  struct spinlock lock;
  struct ksmhd_t ksm[NRKSM];
} ksmtable;

//// KSM handler type
//// Here, use a hash tree to manage all the ksm handlers, complicated yet faster
//struct ksmhd_t {
//  hash_t hash;   // Each ksm handler is associated with a hash value
//  char ksm_name[NAME_MAX+1];  // KSM name
//  struct ksminfo_t* ksminfo;  // KSM info structure
//
//  struct ksmhd_t* father;     //< Hashtree father
//  struct ksmhd_t* left;       //< Hashtree left child
//  struct ksmhd_t* right;      //< Hashtree right child
//
//  struct ksmhd_t* collision_next; //< Collision : next in the linked-list of colliders
//  struct ksmhd_t* collision_prev; //< Collision : previous in the linked-list of colliders
//};

int
ksmget(char* name, uint size)
{
//  if (IS_CREATE(flag)) {
//    uint pgnr = PGROUNDUP(size) >> PGSHIFT;

//  }


}

//int             ksmget(int pid, uint size, int flag);
int             ksmattach(int hd, int flag);
int             ksmdetach(int hd);
int             ksminfo(int hd, struct ksminfo_t* info);
int             ksmdelete(int hd);
