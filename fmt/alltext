0100 typedef unsigned int   uint;
0101 typedef unsigned short ushort;
0102 typedef unsigned char  uchar;
0103 typedef uint pde_t;
0104 
0105 
0106 
0107 
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117 
0118 
0119 
0120 
0121 
0122 
0123 
0124 
0125 
0126 
0127 
0128 
0129 
0130 
0131 
0132 
0133 
0134 
0135 
0136 
0137 
0138 
0139 
0140 
0141 
0142 
0143 
0144 
0145 
0146 
0147 
0148 
0149 
0150 #define NPROC        64  
0151 #define KSTACKSIZE 4096  
0152 #define NCPU          8  
0153 #define NOFILE       16  
0154 #define NFILE       100  
0155 #define NBUF         10  
0156 #define NINODE       50  
0157 #define NDEV         10  
0158 #define ROOTDEV       1  
0159 #define MAXARG       32  
0160 #define LOGSIZE      10  
0161 
0162 
0163 
0164 
0165 
0166 
0167 
0168 
0169 
0170 
0171 
0172 
0173 
0174 
0175 
0176 
0177 
0178 
0179 
0180 
0181 
0182 
0183 
0184 
0185 
0186 
0187 
0188 
0189 
0190 
0191 
0192 
0193 
0194 
0195 
0196 
0197 
0198 
0199 
0200 
0201 
0202 #define EXTMEM  0x100000            
0203 #define PHYSTOP 0xE000000           
0204 #define DEVSPACE 0xFE000000         
0205 
0206 
0207 #define KERNBASE 0x80000000         
0208 #define KERNLINK (KERNBASE+EXTMEM)  
0209 
0210 #ifndef __ASSEMBLER__
0211 
0212 static inline uint v2p(void *a) { return ((uint) (a))  - KERNBASE; }
0213 static inline void *p2v(uint a) { return (void *) ((a) + KERNBASE); }
0214 
0215 #endif
0216 
0217 #define V2P(a) (((uint) (a)) - KERNBASE)
0218 #define P2V(a) (((void *) (a)) + KERNBASE)
0219 
0220 #define V2P_WO(x) ((x) - KERNBASE)    
0221 #define P2V_WO(x) ((x) + KERNBASE)    
0222 
0223 
0224 
0225 
0226 
0227 
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 
0240 
0241 
0242 
0243 
0244 
0245 
0246 
0247 
0248 
0249 
0250 struct buf;
0251 struct context;
0252 struct file;
0253 struct inode;
0254 struct pipe;
0255 struct proc;
0256 struct spinlock;
0257 struct stat;
0258 struct superblock;
0259 
0260 
0261 void            binit(void);
0262 struct buf*     bread(uint, uint);
0263 void            brelse(struct buf*);
0264 void            bwrite(struct buf*);
0265 
0266 
0267 void            consoleinit(void);
0268 void            cprintf(char*, ...);
0269 void            consoleintr(int(*)(void));
0270 void            panic(char*) __attribute__((noreturn));
0271 
0272 
0273 int             exec(char*, char**);
0274 
0275 
0276 struct file*    filealloc(void);
0277 void            fileclose(struct file*);
0278 struct file*    filedup(struct file*);
0279 void            fileinit(void);
0280 int             fileread(struct file*, char*, int n);
0281 int             filestat(struct file*, struct stat*);
0282 int             filewrite(struct file*, char*, int n);
0283 
0284 
0285 void            readsb(int dev, struct superblock *sb);
0286 int             dirlink(struct inode*, char*, uint);
0287 struct inode*   dirlookup(struct inode*, char*, uint*);
0288 struct inode*   ialloc(uint, short);
0289 struct inode*   idup(struct inode*);
0290 void            iinit(void);
0291 void            ilock(struct inode*);
0292 void            iput(struct inode*);
0293 void            iunlock(struct inode*);
0294 void            iunlockput(struct inode*);
0295 void            iupdate(struct inode*);
0296 int             namecmp(const char*, const char*);
0297 struct inode*   namei(char*);
0298 struct inode*   nameiparent(char*, char*);
0299 int             readi(struct inode*, char*, uint, uint);
0300 void            stati(struct inode*, struct stat*);
0301 int             writei(struct inode*, char*, uint, uint);
0302 
0303 
0304 void            ideinit(void);
0305 void            ideintr(void);
0306 void            iderw(struct buf*);
0307 
0308 
0309 void            ioapicenable(int irq, int cpu);
0310 extern uchar    ioapicid;
0311 void            ioapicinit(void);
0312 
0313 
0314 char*           kalloc(void);
0315 void            kfree(char*);
0316 void            kinit1(void*, void*);
0317 void            kinit2(void*, void*);
0318 
0319 
0320 void            kbdintr(void);
0321 
0322 
0323 int             cpunum(void);
0324 extern volatile uint*    lapic;
0325 void            lapiceoi(void);
0326 void            lapicinit(void);
0327 void            lapicstartap(uchar, uint);
0328 void            microdelay(int);
0329 
0330 
0331 void            initlog(void);
0332 void            log_write(struct buf*);
0333 void            begin_trans();
0334 void            commit_trans();
0335 
0336 
0337 extern int      ismp;
0338 int             mpbcpu(void);
0339 void            mpinit(void);
0340 void            mpstartthem(void);
0341 
0342 
0343 void            picenable(int);
0344 void            picinit(void);
0345 
0346 
0347 
0348 
0349 
0350 
0351 int             pipealloc(struct file**, struct file**);
0352 void            pipeclose(struct pipe*, int);
0353 int             piperead(struct pipe*, char*, int);
0354 int             pipewrite(struct pipe*, char*, int);
0355 
0356 
0357 
0358 struct proc*    copyproc(struct proc*);
0359 void            exit(void);
0360 int             fork(void);
0361 int             growproc(int);
0362 int             kill(int);
0363 void            pinit(void);
0364 void            procdump(void);
0365 void            scheduler(void) __attribute__((noreturn));
0366 void            sched(void);
0367 void            sleep(void*, struct spinlock*);
0368 void            userinit(void);
0369 int             wait(void);
0370 void            wakeup(void*);
0371 void            yield(void);
0372 
0373 
0374 void            swtch(struct context**, struct context*);
0375 
0376 
0377 void            acquire(struct spinlock*);
0378 void            getcallerpcs(void*, uint*);
0379 int             holding(struct spinlock*);
0380 void            initlock(struct spinlock*, char*);
0381 void            release(struct spinlock*);
0382 void            pushcli(void);
0383 void            popcli(void);
0384 
0385 
0386 int             memcmp(const void*, const void*, uint);
0387 void*           memmove(void*, const void*, uint);
0388 void*           memset(void*, int, uint);
0389 char*           safestrcpy(char*, const char*, int);
0390 int             strlen(const char*);
0391 int             strncmp(const char*, const char*, uint);
0392 char*           strncpy(char*, const char*, int);
0393 
0394 
0395 int             argint(int, int*);
0396 int             argptr(int, char**, int);
0397 int             argstr(int, char**);
0398 int             fetchint(uint, int*);
0399 int             fetchstr(uint, char**);
0400 void            syscall(void);
0401 
0402 
0403 void            timerinit(void);
0404 
0405 
0406 void            idtinit(void);
0407 extern uint     ticks;
0408 void            tvinit(void);
0409 extern struct spinlock tickslock;
0410 
0411 
0412 void            uartinit(void);
0413 void            uartintr(void);
0414 void            uartputc(int);
0415 
0416 
0417 void            seginit(void);
0418 void            kvmalloc(void);
0419 void            vmenable(void);
0420 pde_t*          setupkvm(void);
0421 char*           uva2ka(pde_t*, char*);
0422 int             allocuvm(pde_t*, uint, uint);
0423 int             deallocuvm(pde_t*, uint, uint);
0424 void            freevm(pde_t*);
0425 void            inituvm(pde_t*, char*, uint);
0426 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
0427 pde_t*          copyuvm(pde_t*, uint);
0428 void            switchuvm(struct proc*);
0429 void            switchkvm(void);
0430 int             copyout(pde_t*, uint, void*, uint);
0431 void            clearpteu(pde_t *pgdir, char *uva);
0432 
0433 
0434 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
0435 
0436 
0437 /* struct ksmhd_t* ksmget(int pid, uint size, int flag); */
0438 /* void*           ksmattach(struct ksmhd_t* hd, int flag); */
0439 /* int             ksmdetach(struct ksmhd_t* hd); */
0440 /* int             ksminfo(struct ksmhd_t* hd, struct ksminfo_t* info); */
0441 /* int             ksmdelete(struct ksmhd_t* hd); */
0442 
0443 
0444 
0445 
0446 
0447 
0448 
0449 
0450 
0451 
0452 static inline uchar
0453 inb(ushort port)
0454 {
0455   uchar data;
0456 
0457   asm volatile("in %1,%0" : "=a" (data) : "d" (port));
0458   return data;
0459 }
0460 
0461 static inline void
0462 insl(int port, void *addr, int cnt)
0463 {
0464   asm volatile("cld; rep insl" :
0465                "=D" (addr), "=c" (cnt) :
0466                "d" (port), "0" (addr), "1" (cnt) :
0467                "memory", "cc");
0468 }
0469 
0470 static inline void
0471 outb(ushort port, uchar data)
0472 {
0473   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0474 }
0475 
0476 static inline void
0477 outw(ushort port, ushort data)
0478 {
0479   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0480 }
0481 
0482 static inline void
0483 outsl(int port, const void *addr, int cnt)
0484 {
0485   asm volatile("cld; rep outsl" :
0486                "=S" (addr), "=c" (cnt) :
0487                "d" (port), "0" (addr), "1" (cnt) :
0488                "cc");
0489 }
0490 
0491 static inline void
0492 stosb(void *addr, int data, int cnt)
0493 {
0494   asm volatile("cld; rep stosb" :
0495                "=D" (addr), "=c" (cnt) :
0496                "0" (addr), "1" (cnt), "a" (data) :
0497                "memory", "cc");
0498 }
0499 
0500 static inline void
0501 stosl(void *addr, int data, int cnt)
0502 {
0503   asm volatile("cld; rep stosl" :
0504                "=D" (addr), "=c" (cnt) :
0505                "0" (addr), "1" (cnt), "a" (data) :
0506                "memory", "cc");
0507 }
0508 
0509 struct segdesc;
0510 
0511 static inline void
0512 lgdt(struct segdesc *p, int size)
0513 {
0514   volatile ushort pd[3];
0515 
0516   pd[0] = size-1;
0517   pd[1] = (uint)p;
0518   pd[2] = (uint)p >> 16;
0519 
0520   asm volatile("lgdt (%0)" : : "r" (pd));
0521 }
0522 
0523 struct gatedesc;
0524 
0525 static inline void
0526 lidt(struct gatedesc *p, int size)
0527 {
0528   volatile ushort pd[3];
0529 
0530   pd[0] = size-1;
0531   pd[1] = (uint)p;
0532   pd[2] = (uint)p >> 16;
0533 
0534   asm volatile("lidt (%0)" : : "r" (pd));
0535 }
0536 
0537 static inline void
0538 ltr(ushort sel)
0539 {
0540   asm volatile("ltr %0" : : "r" (sel));
0541 }
0542 
0543 static inline uint
0544 readeflags(void)
0545 {
0546   uint eflags;
0547   asm volatile("pushfl; popl %0" : "=r" (eflags));
0548   return eflags;
0549 }
0550 static inline void
0551 loadgs(ushort v)
0552 {
0553   asm volatile("movw %0, %%gs" : : "r" (v));
0554 }
0555 
0556 static inline void
0557 cli(void)
0558 {
0559   asm volatile("cli");
0560 }
0561 
0562 static inline void
0563 sti(void)
0564 {
0565   asm volatile("sti");
0566 }
0567 
0568 static inline uint
0569 xchg(volatile uint *addr, uint newval)
0570 {
0571   uint result;
0572 
0573   
0574   asm volatile("lock; xchgl %0, %1" :
0575                "+m" (*addr), "=a" (result) :
0576                "1" (newval) :
0577                "cc");
0578   return result;
0579 }
0580 
0581 static inline uint
0582 rcr2(void)
0583 {
0584   uint val;
0585   asm volatile("movl %%cr2,%0" : "=r" (val));
0586   return val;
0587 }
0588 
0589 static inline void
0590 lcr3(uint val)
0591 {
0592   asm volatile("movl %0,%%cr3" : : "r" (val));
0593 }
0594 
0595 
0596 
0597 
0598 
0599 
0600 
0601 
0602 struct trapframe {
0603   
0604   uint edi;
0605   uint esi;
0606   uint ebp;
0607   uint oesp;      
0608   uint ebx;
0609   uint edx;
0610   uint ecx;
0611   uint eax;
0612 
0613   
0614   ushort gs;
0615   ushort padding1;
0616   ushort fs;
0617   ushort padding2;
0618   ushort es;
0619   ushort padding3;
0620   ushort ds;
0621   ushort padding4;
0622   uint trapno;
0623 
0624   
0625   uint err;
0626   uint eip;
0627   ushort cs;
0628   ushort padding5;
0629   uint eflags;
0630 
0631   
0632   uint esp;
0633   ushort ss;
0634   ushort padding6;
0635 };
0636 
0637 
0638 
0639 
0640 
0641 
0642 
0643 
0644 
0645 
0646 
0647 
0648 
0649 
0650 
0651 
0652 
0653 
0654 #define SEG_NULLASM                                             \
0655         .word 0, 0;                                             \
0656         .byte 0, 0, 0, 0
0657 
0658 
0659 
0660 #define SEG_ASM(type,base,lim)                                  \
0661         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
0662         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
0663                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
0664 
0665 #define STA_X     0x8       
0666 #define STA_E     0x4       
0667 #define STA_C     0x4       
0668 #define STA_W     0x2       
0669 #define STA_R     0x2       
0670 #define STA_A     0x1       
0671 
0672 
0673 
0674 
0675 
0676 
0677 
0678 
0679 
0680 
0681 
0682 
0683 
0684 
0685 
0686 
0687 
0688 
0689 
0690 
0691 
0692 
0693 
0694 
0695 
0696 
0697 
0698 
0699 
0700 
0701 
0702 
0703 
0704 #define FL_CF           0x00000001      
0705 #define FL_PF           0x00000004      
0706 #define FL_AF           0x00000010      
0707 #define FL_ZF           0x00000040      
0708 #define FL_SF           0x00000080      
0709 #define FL_TF           0x00000100      
0710 #define FL_IF           0x00000200      
0711 #define FL_DF           0x00000400      
0712 #define FL_OF           0x00000800      
0713 #define FL_IOPL_MASK    0x00003000      
0714 #define FL_IOPL_0       0x00000000      
0715 #define FL_IOPL_1       0x00001000      
0716 #define FL_IOPL_2       0x00002000      
0717 #define FL_IOPL_3       0x00003000      
0718 #define FL_NT           0x00004000      
0719 #define FL_RF           0x00010000      
0720 #define FL_VM           0x00020000      
0721 #define FL_AC           0x00040000      
0722 #define FL_VIF          0x00080000      
0723 #define FL_VIP          0x00100000      
0724 #define FL_ID           0x00200000      
0725 
0726 
0727 #define CR0_PE          0x00000001      
0728 #define CR0_MP          0x00000002      
0729 #define CR0_EM          0x00000004      
0730 #define CR0_TS          0x00000008      
0731 #define CR0_ET          0x00000010      
0732 #define CR0_NE          0x00000020      
0733 #define CR0_WP          0x00010000      
0734 #define CR0_AM          0x00040000      
0735 #define CR0_NW          0x20000000      
0736 #define CR0_CD          0x40000000      
0737 #define CR0_PG          0x80000000      
0738 
0739 #define CR4_PSE         0x00000010      
0740 
0741 #define SEG_KCODE 1  
0742 #define SEG_KDATA 2  
0743 #define SEG_KCPU  3  
0744 #define SEG_UCODE 4  
0745 #define SEG_UDATA 5  
0746 #define SEG_TSS   6  
0747 
0748 
0749 
0750 #ifndef __ASSEMBLER__
0751 
0752 struct segdesc {
0753   uint lim_15_0 : 16;  
0754   uint base_15_0 : 16; 
0755   uint base_23_16 : 8; 
0756   uint type : 4;       
0757   uint s : 1;          
0758   uint dpl : 2;        
0759   uint p : 1;          
0760   uint lim_19_16 : 4;  
0761   uint avl : 1;        
0762   uint rsv1 : 1;       
0763   uint db : 1;         
0764   uint g : 1;          
0765   uint base_31_24 : 8; 
0766 };
0767 
0768 
0769 #define SEG(type, base, lim, dpl) (struct segdesc)    \
0770 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
0771   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0772   (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
0773 #define SEG16(type, base, lim, dpl) (struct segdesc)  \
0774 { (lim) & 0xffff, (uint)(base) & 0xffff,              \
0775   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0776   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
0777 #endif
0778 
0779 #define DPL_USER    0x3     
0780 
0781 
0782 #define STA_X       0x8     
0783 #define STA_E       0x4     
0784 #define STA_C       0x4     
0785 #define STA_W       0x2     
0786 #define STA_R       0x2     
0787 #define STA_A       0x1     
0788 
0789 
0790 #define STS_T16A    0x1     
0791 #define STS_LDT     0x2     
0792 #define STS_T16B    0x3     
0793 #define STS_CG16    0x4     
0794 #define STS_TG      0x5     
0795 #define STS_IG16    0x6     
0796 #define STS_TG16    0x7     
0797 #define STS_T32A    0x9     
0798 #define STS_T32B    0xB     
0799 #define STS_CG32    0xC     
0800 #define STS_IG32    0xE     
0801 #define STS_TG32    0xF     
0802 
0803 
0804 
0805 
0806 
0807 
0808 
0809 
0810 
0811 
0812 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
0813 
0814 
0815 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
0816 
0817 
0818 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
0819 
0820 
0821 #define NPDENTRIES      1024    
0822 #define NPTENTRIES      1024    
0823 #define PGSIZE          4096    
0824 
0825 #define PGSHIFT         12      
0826 #define PTXSHIFT        12      
0827 #define PDXSHIFT        22      
0828 
0829 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
0830 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
0831 
0832 
0833 #define PTE_P           0x001   
0834 #define PTE_W           0x002   
0835 #define PTE_U           0x004   
0836 #define PTE_PWT         0x008   
0837 #define PTE_PCD         0x010   
0838 #define PTE_A           0x020   
0839 #define PTE_D           0x040   
0840 #define PTE_PS          0x080   
0841 #define PTE_MBZ         0x180   
0842 
0843 
0844 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
0845 
0846 #ifndef __ASSEMBLER__
0847 typedef uint pte_t;
0848 
0849 
0850 
0851 struct taskstate {
0852   uint link;         
0853   uint esp0;         
0854   ushort ss0;        
0855   ushort padding1;
0856   uint *esp1;
0857   ushort ss1;
0858   ushort padding2;
0859   uint *esp2;
0860   ushort ss2;
0861   ushort padding3;
0862   void *cr3;         
0863   uint *eip;         
0864   uint eflags;
0865   uint eax;          
0866   uint ecx;
0867   uint edx;
0868   uint ebx;
0869   uint *esp;
0870   uint *ebp;
0871   uint esi;
0872   uint edi;
0873   ushort es;         
0874   ushort padding4;
0875   ushort cs;
0876   ushort padding5;
0877   ushort ss;
0878   ushort padding6;
0879   ushort ds;
0880   ushort padding7;
0881   ushort fs;
0882   ushort padding8;
0883   ushort gs;
0884   ushort padding9;
0885   ushort ldt;
0886   ushort padding10;
0887   ushort t;          
0888   ushort iomb;       
0889 };
0890 
0891 
0892 
0893 
0894 
0895 
0896 
0897 
0898 
0899 
0900 
0901 struct gatedesc {
0902   uint off_15_0 : 16;   
0903   uint cs : 16;         
0904   uint args : 5;        
0905   uint rsv1 : 3;        
0906   uint type : 4;        
0907   uint s : 1;           
0908   uint dpl : 2;         
0909   uint p : 1;           
0910   uint off_31_16 : 16;  
0911 };
0912 
0913 
0914 
0915 
0916 
0917 
0918 
0919 
0920 
0921 #define SETGATE(gate, istrap, sel, off, d)                \
0922 {                                                         \
0923   (gate).off_15_0 = (uint)(off) & 0xffff;                \
0924   (gate).cs = (sel);                                      \
0925   (gate).args = 0;                                        \
0926   (gate).rsv1 = 0;                                        \
0927   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
0928   (gate).s = 0;                                           \
0929   (gate).dpl = (d);                                       \
0930   (gate).p = 1;                                           \
0931   (gate).off_31_16 = (uint)(off) >> 16;                  \
0932 }
0933 
0934 #endif
0935 
0936 
0937 
0938 
0939 
0940 
0941 
0942 
0943 
0944 
0945 
0946 
0947 
0948 
0949 
0950 
0951 
0952 #define ELF_MAGIC 0x464C457FU  
0953 
0954 
0955 struct elfhdr {
0956   uint magic;  
0957   uchar elf[12];
0958   ushort type;
0959   ushort machine;
0960   uint version;
0961   uint entry;
0962   uint phoff;
0963   uint shoff;
0964   uint flags;
0965   ushort ehsize;
0966   ushort phentsize;
0967   ushort phnum;
0968   ushort shentsize;
0969   ushort shnum;
0970   ushort shstrndx;
0971 };
0972 
0973 
0974 struct proghdr {
0975   uint type;
0976   uint off;
0977   uint vaddr;
0978   uint paddr;
0979   uint filesz;
0980   uint memsz;
0981   uint flags;
0982   uint align;
0983 };
0984 
0985 
0986 #define ELF_PROG_LOAD           1
0987 
0988 
0989 #define ELF_PROG_FLAG_EXEC      1
0990 #define ELF_PROG_FLAG_WRITE     2
0991 #define ELF_PROG_FLAG_READ      4
0992 
0993 
0994 
0995 
0996 
0997 
0998 
0999 
1000 
1001 
1002 
1003 
1004 
1005 
1006 
1007 
1008 
1009 
1010 
1011 
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 .p2align 2
1023 .text
1024 .globl multiboot_header
1025 multiboot_header:
1026   
1027   
1028   .long magic
1029   .long flags
1030   .long (-magic-flags)
1031 
1032 
1033 
1034 
1035 .globl _start
1036 _start = V2P_WO(entry)
1037 
1038 
1039 .globl entry
1040 entry:
1041   
1042   movl    %cr4, %eax
1043   orl     $(CR4_PSE), %eax
1044   movl    %eax, %cr4
1045   
1046   movl    $(V2P_WO(entrypgdir)), %eax
1047   movl    %eax, %cr3
1048   
1049   movl    %cr0, %eax
1050   orl     $(CR0_PG|CR0_WP), %eax
1051   movl    %eax, %cr0
1052 
1053   
1054   movl $(stack + KSTACKSIZE), %esp
1055 
1056   
1057   
1058   
1059   
1060   mov $main, %eax
1061   jmp *%eax
1062 
1063 .comm stack, KSTACKSIZE
1064 
1065 
1066 
1067 
1068 
1069 
1070 
1071 
1072 
1073 
1074 
1075 
1076 
1077 
1078 
1079 
1080 
1081 
1082 
1083 
1084 
1085 
1086 
1087 
1088 
1089 
1090 
1091 
1092 
1093 
1094 
1095 
1096 
1097 
1098 
1099 
1100 
1101 
1102 
1103 
1104 
1105 
1106 
1107 
1108 
1109 
1110 
1111 
1112 
1113 
1114 
1115 
1116 
1117 
1118 
1119 
1120 
1121 
1122 
1123 .code16
1124 .globl start
1125 start:
1126   cli
1127 
1128   xorw    %ax,%ax
1129   movw    %ax,%ds
1130   movw    %ax,%es
1131   movw    %ax,%ss
1132 
1133   lgdt    gdtdesc
1134   movl    %cr0, %eax
1135   orl     $CR0_PE, %eax
1136   movl    %eax, %cr0
1137 
1138 
1139 
1140 
1141 
1142 
1143 
1144 
1145 
1146 
1147 
1148 
1149 
1150   ljmpl    $(SEG_KCODE<<3), $(start32)
1151 
1152 .code32
1153 start32:
1154   movw    $(SEG_KDATA<<3), %ax
1155   movw    %ax, %ds
1156   movw    %ax, %es
1157   movw    %ax, %ss
1158   movw    $0, %ax
1159   movw    %ax, %fs
1160   movw    %ax, %gs
1161 
1162   
1163   movl    %cr4, %eax
1164   orl     $(CR4_PSE), %eax
1165   movl    %eax, %cr4
1166   
1167   movl    (start-12), %eax
1168   movl    %eax, %cr3
1169   
1170   movl    %cr0, %eax
1171   orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
1172   movl    %eax, %cr0
1173 
1174   
1175   movl    (start-4), %esp
1176   
1177   call	 *(start-8)
1178 
1179   movw    $0x8a00, %ax
1180   movw    %ax, %dx
1181   outw    %ax, %dx
1182   movw    $0x8ae0, %ax
1183   outw    %ax, %dx
1184 spin:
1185   jmp     spin
1186 
1187 .p2align 2
1188 gdt:
1189   SEG_NULLASM
1190   SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
1191   SEG_ASM(STA_W, 0, 0xffffffff)
1192 
1193 
1194 gdtdesc:
1195   .word   (gdtdesc - gdt - 1)
1196   .long   gdt
1197 
1198 
1199 
1200 #include "types.h"
1201 #include "defs.h"
1202 #include "param.h"
1203 #include "memlayout.h"
1204 #include "mmu.h"
1205 #include "proc.h"
1206 #include "x86.h"
1207 
1208 static void startothers(void);
1209 static void mpmain(void)  __attribute__((noreturn));
1210 extern pde_t *kpgdir;
1211 extern char end[]; 
1212 
1213 
1214 
1215 
1216 int
1217 main(void)
1218 {
1219   kinit1(end, P2V(4*1024*1024)); 
1220   kvmalloc();      
1221   mpinit();        
1222   lapicinit();
1223   seginit();       
1224   cprintf("\ncpu%d: starting xv6\n\n", cpu->id);
1225   picinit();       
1226   ioapicinit();    
1227   consoleinit();   
1228   uartinit();      
1229   pinit();         
1230   tvinit();        
1231   binit();         
1232   fileinit();      
1233   iinit();         
1234   ideinit();       
1235   if(!ismp)
1236     timerinit();   
1237   startothers();   
1238   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); 
1239   userinit();      
1240   
1241   mpmain();
1242 }
1243 
1244 
1245 
1246 
1247 
1248 
1249 
1250 
1251 static void
1252 mpenter(void)
1253 {
1254   switchkvm();
1255   seginit();
1256   lapicinit();
1257   mpmain();
1258 }
1259 
1260 
1261 static void
1262 mpmain(void)
1263 {
1264   cprintf("cpu%d: starting\n", cpu->id);
1265   idtinit();       
1266   xchg(&cpu->started, 1); 
1267   scheduler();     
1268 }
1269 
1270 pde_t entrypgdir[];  
1271 
1272 
1273 static void
1274 startothers(void)
1275 {
1276   extern uchar _binary_entryother_start[], _binary_entryother_size[];
1277   uchar *code;
1278   struct cpu *c;
1279   char *stack;
1280 
1281   
1282   
1283   
1284   code = p2v(0x7000);
1285   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
1286 
1287   for(c = cpus; c < cpus+ncpu; c++){
1288     if(c == cpus+cpunum())  
1289       continue;
1290 
1291     
1292     
1293     
1294     stack = kalloc();
1295     *(void**)(code-4) = stack + KSTACKSIZE;
1296     *(void**)(code-8) = mpenter;
1297     *(int**)(code-12) = (void *) v2p(entrypgdir);
1298 
1299     lapicstartap(c->id, v2p(code));
1300     
1301     while(c->started == 0)
1302       ;
1303   }
1304 }
1305 
1306 
1307 
1308 
1309 
1310 __attribute__((__aligned__(PGSIZE)))
1311 pde_t entrypgdir[NPDENTRIES] = {
1312   
1313   [0] = (0) | PTE_P | PTE_W | PTE_PS,
1314   
1315   [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
1316 };
1317 
1318 
1319 
1320 
1321 
1322 
1323 
1324 
1325 
1326 
1327 
1328 
1329 
1330 
1331 
1332 
1333 
1334 
1335 
1336 
1337 
1338 
1339 
1340 
1341 
1342 
1343 
1344 
1345 
1346 
1347 
1348 
1349 
1350 
1351 
1352 
1353 
1354 
1355 
1356 
1357 
1358 
1359 
1360 
1361 
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 struct spinlock {
1402   uint locked;       
1403 
1404   
1405   char *name;        
1406   struct cpu *cpu;   
1407   uint pcs[10];      
1408                      
1409 };
1410 
1411 
1412 
1413 
1414 
1415 
1416 
1417 
1418 
1419 
1420 
1421 
1422 
1423 
1424 
1425 
1426 
1427 
1428 
1429 
1430 
1431 
1432 
1433 
1434 
1435 
1436 
1437 
1438 
1439 
1440 
1441 
1442 
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 
1452 #include "types.h"
1453 #include "defs.h"
1454 #include "param.h"
1455 #include "x86.h"
1456 #include "memlayout.h"
1457 #include "mmu.h"
1458 #include "proc.h"
1459 #include "spinlock.h"
1460 
1461 void
1462 initlock(struct spinlock *lk, char *name)
1463 {
1464   lk->name = name;
1465   lk->locked = 0;
1466   lk->cpu = 0;
1467 }
1468 
1469 
1470 
1471 
1472 
1473 void
1474 acquire(struct spinlock *lk)
1475 {
1476   pushcli(); 
1477   if(holding(lk))
1478     panic("acquire");
1479 
1480   
1481   
1482   
1483   while(xchg(&lk->locked, 1) != 0)
1484     ;
1485 
1486   
1487   lk->cpu = cpu;
1488   getcallerpcs(&lk, lk->pcs);
1489 }
1490 
1491 
1492 
1493 
1494 
1495 
1496 
1497 
1498 
1499 
1500 
1501 void
1502 release(struct spinlock *lk)
1503 {
1504   if(!holding(lk))
1505     panic("release");
1506 
1507   lk->pcs[0] = 0;
1508   lk->cpu = 0;
1509 
1510   
1511   
1512   
1513   
1514   
1515   
1516   
1517   
1518   
1519   xchg(&lk->locked, 0);
1520 
1521   popcli();
1522 }
1523 
1524 
1525 void
1526 getcallerpcs(void *v, uint pcs[])
1527 {
1528   uint *ebp;
1529   int i;
1530 
1531   ebp = (uint*)v - 2;
1532   for(i = 0; i < 10; i++){
1533     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
1534       break;
1535     pcs[i] = ebp[1];     
1536     ebp = (uint*)ebp[0]; 
1537   }
1538   for(; i < 10; i++)
1539     pcs[i] = 0;
1540 }
1541 
1542 
1543 int
1544 holding(struct spinlock *lock)
1545 {
1546   return lock->locked && lock->cpu == cpu;
1547 }
1548 
1549 
1550 
1551 
1552 
1553 
1554 void
1555 pushcli(void)
1556 {
1557   int eflags;
1558 
1559   eflags = readeflags();
1560   cli();
1561   if(cpu->ncli++ == 0)
1562     cpu->intena = eflags & FL_IF;
1563 }
1564 
1565 void
1566 popcli(void)
1567 {
1568   if(readeflags()&FL_IF)
1569     panic("popcli - interruptible");
1570   if(--cpu->ncli < 0)
1571     panic("popcli");
1572   if(cpu->ncli == 0 && cpu->intena)
1573     sti();
1574 }
1575 
1576 
1577 
1578 
1579 
1580 
1581 
1582 
1583 
1584 
1585 
1586 
1587 
1588 
1589 
1590 
1591 
1592 
1593 
1594 
1595 
1596 
1597 
1598 
1599 
1600 #include "param.h"
1601 #include "types.h"
1602 #include "defs.h"
1603 #include "x86.h"
1604 #include "memlayout.h"
1605 #include "mmu.h"
1606 #include "proc.h"
1607 #include "elf.h"
1608 
1609 extern char data[];  
1610 pde_t *kpgdir;  
1611 struct segdesc gdt[NSEGS];
1612 
1613 
1614 
1615 void
1616 seginit(void)
1617 {
1618   struct cpu *c;
1619 
1620   
1621   
1622   
1623   
1624   c = &cpus[cpunum()];
1625   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1626   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1627   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1628   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
1629 
1630   
1631   c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
1632 
1633   lgdt(c->gdt, sizeof(c->gdt));
1634   loadgs(SEG_KCPU << 3);
1635 
1636   
1637   cpu = c;
1638   proc = 0;
1639 }
1640 
1641 
1642 
1643 
1644 
1645 
1646 
1647 
1648 
1649 
1650 
1651 
1652 
1653 static pte_t *
1654 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1655 {
1656   pde_t *pde;
1657   pte_t *pgtab;
1658 
1659   pde = &pgdir[PDX(va)];
1660   if(*pde & PTE_P){
1661     pgtab = (pte_t*)p2v(PTE_ADDR(*pde));
1662   } else {
1663     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1664       return 0;
1665     
1666     memset(pgtab, 0, PGSIZE);
1667     
1668     
1669     
1670     *pde = v2p(pgtab) | PTE_P | PTE_W | PTE_U;
1671   }
1672   return &pgtab[PTX(va)];
1673 }
1674 
1675 
1676 
1677 
1678 static int
1679 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
1680 {
1681   char *a, *last;
1682   pte_t *pte;
1683 
1684   a = (char*)PGROUNDDOWN((uint)va);
1685   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
1686   for(;;){
1687     if((pte = walkpgdir(pgdir, a, 1)) == 0)
1688       return -1;
1689     if(*pte & PTE_P)
1690       panic("remap");
1691     *pte = pa | perm | PTE_P;
1692     if(a == last)
1693       break;
1694     a += PGSIZE;
1695     pa += PGSIZE;
1696   }
1697   return 0;
1698 }
1699 
1700 
1701 
1702 
1703 
1704 
1705 
1706 
1707 
1708 
1709 
1710 
1711 
1712 
1713 
1714 
1715 
1716 
1717 
1718 
1719 
1720 
1721 
1722 
1723 static struct kmap {
1724   void *virt;
1725   uint phys_start;
1726   uint phys_end;
1727   int perm;
1728 } kmap[] = {
1729  { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, 
1730  { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     
1731  { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, 
1732  { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, 
1733 };
1734 
1735 
1736 pde_t*
1737 setupkvm(void)
1738 {
1739   pde_t *pgdir;
1740   struct kmap *k;
1741 
1742   if((pgdir = (pde_t*)kalloc()) == 0)
1743     return 0;
1744   memset(pgdir, 0, PGSIZE);
1745   if (p2v(PHYSTOP) > (void*)DEVSPACE)
1746     panic("PHYSTOP too high");
1747   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1748     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
1749                 (uint)k->phys_start, k->perm) < 0)
1750       return 0;
1751   return pgdir;
1752 }
1753 
1754 
1755 
1756 void
1757 kvmalloc(void)
1758 {
1759   kpgdir = setupkvm();
1760   switchkvm();
1761 }
1762 
1763 
1764 
1765 void
1766 switchkvm(void)
1767 {
1768   lcr3(v2p(kpgdir));   
1769 }
1770 
1771 
1772 void
1773 switchuvm(struct proc *p)
1774 {
1775   pushcli();
1776   cpu->gdt[SEG_TSS] = SEG16(STS_T32A, &cpu->ts, sizeof(cpu->ts)-1, 0);
1777   cpu->gdt[SEG_TSS].s = 0;
1778   cpu->ts.ss0 = SEG_KDATA << 3;
1779   cpu->ts.esp0 = (uint)proc->kstack + KSTACKSIZE;
1780   ltr(SEG_TSS << 3);
1781   if(p->pgdir == 0)
1782     panic("switchuvm: no pgdir");
1783   lcr3(v2p(p->pgdir));  
1784   popcli();
1785 }
1786 
1787 
1788 
1789 
1790 
1791 
1792 
1793 
1794 
1795 
1796 
1797 
1798 
1799 
1800 
1801 
1802 void
1803 inituvm(pde_t *pgdir, char *init, uint sz)
1804 {
1805   char *mem;
1806 
1807   if(sz >= PGSIZE)
1808     panic("inituvm: more than a page");
1809   mem = kalloc();
1810   memset(mem, 0, PGSIZE);
1811   mappages(pgdir, 0, PGSIZE, v2p(mem), PTE_W|PTE_U);
1812   memmove(mem, init, sz);
1813 }
1814 
1815 
1816 
1817 int
1818 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
1819 {
1820   uint i, pa, n;
1821   pte_t *pte;
1822 
1823   if((uint) addr % PGSIZE != 0)
1824     panic("loaduvm: addr must be page aligned");
1825   for(i = 0; i < sz; i += PGSIZE){
1826     if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
1827       panic("loaduvm: address should exist");
1828     pa = PTE_ADDR(*pte);
1829     if(sz - i < PGSIZE)
1830       n = sz - i;
1831     else
1832       n = PGSIZE;
1833     if(readi(ip, p2v(pa), offset+i, n) != n)
1834       return -1;
1835   }
1836   return 0;
1837 }
1838 
1839 
1840 
1841 
1842 
1843 
1844 
1845 
1846 
1847 
1848 
1849 
1850 
1851 
1852 int
1853 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1854 {
1855   char *mem;
1856   uint a;
1857 
1858   if(newsz >= KERNBASE)
1859     return 0;
1860   if(newsz < oldsz)
1861     return oldsz;
1862 
1863   a = PGROUNDUP(oldsz);
1864   for(; a < newsz; a += PGSIZE){
1865     mem = kalloc();
1866     if(mem == 0){
1867       cprintf("allocuvm out of memory\n");
1868       deallocuvm(pgdir, newsz, oldsz);
1869       return 0;
1870     }
1871     memset(mem, 0, PGSIZE);
1872     mappages(pgdir, (char*)a, PGSIZE, v2p(mem), PTE_W|PTE_U);
1873   }
1874   return newsz;
1875 }
1876 
1877 
1878 
1879 
1880 
1881 int
1882 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1883 {
1884   pte_t *pte;
1885   uint a, pa;
1886 
1887   if(newsz >= oldsz)
1888     return oldsz;
1889 
1890   a = PGROUNDUP(newsz);
1891   for(; a  < oldsz; a += PGSIZE){
1892     pte = walkpgdir(pgdir, (char*)a, 0);
1893     if(!pte)
1894       a += (NPTENTRIES - 1) * PGSIZE;
1895     else if((*pte & PTE_P) != 0){
1896       pa = PTE_ADDR(*pte);
1897       if(pa == 0)
1898         panic("kfree");
1899       char *v = p2v(pa);
1900       kfree(v);
1901       *pte = 0;
1902     }
1903   }
1904   return newsz;
1905 }
1906 
1907 
1908 
1909 void
1910 freevm(pde_t *pgdir)
1911 {
1912   uint i;
1913 
1914   if(pgdir == 0)
1915     panic("freevm: no pgdir");
1916   deallocuvm(pgdir, KERNBASE, 0);
1917   for(i = 0; i < NPDENTRIES; i++){
1918     if(pgdir[i] & PTE_P){
1919       char * v = p2v(PTE_ADDR(pgdir[i]));
1920       kfree(v);
1921     }
1922   }
1923   kfree((char*)pgdir);
1924 }
1925 
1926 
1927 
1928 void
1929 clearpteu(pde_t *pgdir, char *uva)
1930 {
1931   pte_t *pte;
1932 
1933   pte = walkpgdir(pgdir, uva, 0);
1934   if(pte == 0)
1935     panic("clearpteu");
1936   *pte &= ~PTE_U;
1937 }
1938 
1939 
1940 
1941 
1942 
1943 
1944 
1945 
1946 
1947 
1948 
1949 
1950 
1951 
1952 pde_t*
1953 copyuvm(pde_t *pgdir, uint sz)
1954 {
1955   pde_t *d;
1956   pte_t *pte;
1957   uint pa, i;
1958   char *mem;
1959 
1960   if((d = setupkvm()) == 0)
1961     return 0;
1962   for(i = 0; i < sz; i += PGSIZE){
1963     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
1964       panic("copyuvm: pte should exist");
1965     if(!(*pte & PTE_P))
1966       panic("copyuvm: page not present");
1967     pa = PTE_ADDR(*pte);
1968     if((mem = kalloc()) == 0)
1969       goto bad;
1970     memmove(mem, (char*)p2v(pa), PGSIZE);
1971     if(mappages(d, (void*)i, PGSIZE, v2p(mem), PTE_W|PTE_U) < 0)
1972       goto bad;
1973   }
1974   return d;
1975 
1976 bad:
1977   freevm(d);
1978   return 0;
1979 }
1980 
1981 
1982 
1983 
1984 
1985 
1986 
1987 
1988 
1989 
1990 
1991 
1992 
1993 
1994 
1995 
1996 
1997 
1998 
1999 
2000 
2001 char*
2002 uva2ka(pde_t *pgdir, char *uva)
2003 {
2004   pte_t *pte;
2005 
2006   pte = walkpgdir(pgdir, uva, 0);
2007   if((*pte & PTE_P) == 0)
2008     return 0;
2009   if((*pte & PTE_U) == 0)
2010     return 0;
2011   return (char*)p2v(PTE_ADDR(*pte));
2012 }
2013 
2014 
2015 
2016 
2017 int
2018 copyout(pde_t *pgdir, uint va, void *p, uint len)
2019 {
2020   char *buf, *pa0;
2021   uint n, va0;
2022 
2023   buf = (char*)p;
2024   while(len > 0){
2025     va0 = (uint)PGROUNDDOWN(va);
2026     pa0 = uva2ka(pgdir, (char*)va0);
2027     if(pa0 == 0)
2028       return -1;
2029     n = PGSIZE - (va - va0);
2030     if(n > len)
2031       n = len;
2032     memmove(pa0 + (va - va0), buf, n);
2033     len -= n;
2034     buf += n;
2035     va = va0 + PGSIZE;
2036   }
2037   return 0;
2038 }
2039 
2040 
2041 
2042 
2043 
2044 
2045 
2046 
2047 
2048 
2049 
2050 
2051 #define NSEGS     7
2052 
2053 
2054 struct cpu {
2055   uchar id;                    
2056   struct context *scheduler;   
2057   struct taskstate ts;         
2058   struct segdesc gdt[NSEGS];   
2059   volatile uint started;       
2060   int ncli;                    
2061   int intena;                  
2062 
2063   
2064   struct cpu *cpu;
2065   struct proc *proc;           
2066 };
2067 
2068 extern struct cpu cpus[NCPU];
2069 extern int ncpu;
2070 
2071 
2072 
2073 
2074 
2075 
2076 
2077 
2078 
2079 extern struct cpu *cpu asm("%gs:0");       
2080 extern struct proc *proc asm("%gs:4");     
2081 
2082 
2083 
2084 
2085 
2086 
2087 
2088 
2089 
2090 
2091 
2092 
2093 struct context {
2094   uint edi;
2095   uint esi;
2096   uint ebx;
2097   uint ebp;
2098   uint eip;
2099 };
2100 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2101 
2102 
2103 struct proc {
2104   uint sz;                     
2105   pde_t* pgdir;                
2106   char *kstack;                
2107   enum procstate state;        
2108   volatile int pid;            
2109   struct proc *parent;         
2110   struct trapframe *tf;        
2111   struct context *context;     
2112   void *chan;                  
2113   int killed;                  
2114   struct file *ofile[NOFILE];  
2115   struct inode *cwd;           
2116   char name[16];               
2117 };
2118 
2119 
2120 
2121 
2122 
2123 
2124 
2125 
2126 
2127 
2128 
2129 
2130 
2131 
2132 
2133 
2134 
2135 
2136 
2137 
2138 
2139 
2140 
2141 
2142 
2143 
2144 
2145 
2146 
2147 
2148 
2149 
2150 #include "types.h"
2151 #include "defs.h"
2152 #include "param.h"
2153 #include "memlayout.h"
2154 #include "mmu.h"
2155 #include "x86.h"
2156 #include "proc.h"
2157 #include "spinlock.h"
2158 
2159 struct {
2160   struct spinlock lock;
2161   struct proc proc[NPROC];
2162 } ptable;
2163 
2164 static struct proc *initproc;
2165 
2166 int nextpid = 1;
2167 extern void forkret(void);
2168 extern void trapret(void);
2169 
2170 static void wakeup1(void *chan);
2171 
2172 void
2173 pinit(void)
2174 {
2175   initlock(&ptable.lock, "ptable");
2176 }
2177 
2178 
2179 
2180 
2181 
2182 
2183 
2184 
2185 
2186 
2187 
2188 
2189 
2190 
2191 
2192 
2193 
2194 
2195 
2196 
2197 
2198 
2199 
2200 
2201 
2202 
2203 
2204 static struct proc*
2205 allocproc(void)
2206 {
2207   struct proc *p;
2208   char *sp;
2209 
2210   acquire(&ptable.lock);
2211   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2212     if(p->state == UNUSED)
2213       goto found;
2214   release(&ptable.lock);
2215   return 0;
2216 
2217 found:
2218   p->state = EMBRYO;
2219   p->pid = nextpid++;
2220   release(&ptable.lock);
2221 
2222   
2223   if((p->kstack = kalloc()) == 0){
2224     p->state = UNUSED;
2225     return 0;
2226   }
2227   sp = p->kstack + KSTACKSIZE;
2228 
2229   
2230   sp -= sizeof *p->tf;
2231   p->tf = (struct trapframe*)sp;
2232 
2233   
2234   
2235   sp -= 4;
2236   *(uint*)sp = (uint)trapret;
2237 
2238   sp -= sizeof *p->context;
2239   p->context = (struct context*)sp;
2240   memset(p->context, 0, sizeof *p->context);
2241   p->context->eip = (uint)forkret;
2242 
2243   return p;
2244 }
2245 
2246 
2247 
2248 
2249 
2250 
2251 void
2252 userinit(void)
2253 {
2254   struct proc *p;
2255   extern char _binary_initcode_start[], _binary_initcode_size[];
2256 
2257   p = allocproc();
2258   initproc = p;
2259   if((p->pgdir = setupkvm()) == 0)
2260     panic("userinit: out of memory?");
2261   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
2262   p->sz = PGSIZE;
2263   memset(p->tf, 0, sizeof(*p->tf));
2264   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
2265   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
2266   p->tf->es = p->tf->ds;
2267   p->tf->ss = p->tf->ds;
2268   p->tf->eflags = FL_IF;
2269   p->tf->esp = PGSIZE;
2270   p->tf->eip = 0;  
2271 
2272   safestrcpy(p->name, "initcode", sizeof(p->name));
2273   p->cwd = namei("/");
2274 
2275   p->state = RUNNABLE;
2276 }
2277 
2278 
2279 
2280 int
2281 growproc(int n)
2282 {
2283   uint sz;
2284 
2285   sz = proc->sz;
2286   if(n > 0){
2287     if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
2288       return -1;
2289   } else if(n < 0){
2290     if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
2291       return -1;
2292   }
2293   proc->sz = sz;
2294   switchuvm(proc);
2295   return 0;
2296 }
2297 
2298 
2299 
2300 
2301 
2302 
2303 int
2304 fork(void)
2305 {
2306   int i, pid;
2307   struct proc *np;
2308 
2309   
2310   if((np = allocproc()) == 0)
2311     return -1;
2312 
2313   
2314   if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
2315     kfree(np->kstack);
2316     np->kstack = 0;
2317     np->state = UNUSED;
2318     return -1;
2319   }
2320   np->sz = proc->sz;
2321   np->parent = proc;
2322   *np->tf = *proc->tf;
2323 
2324   
2325   np->tf->eax = 0;
2326 
2327   for(i = 0; i < NOFILE; i++)
2328     if(proc->ofile[i])
2329       np->ofile[i] = filedup(proc->ofile[i]);
2330   np->cwd = idup(proc->cwd);
2331 
2332   pid = np->pid;
2333   np->state = RUNNABLE;
2334   safestrcpy(np->name, proc->name, sizeof(proc->name));
2335   return pid;
2336 }
2337 
2338 
2339 
2340 
2341 
2342 
2343 
2344 
2345 
2346 
2347 
2348 
2349 
2350 
2351 
2352 
2353 void
2354 exit(void)
2355 {
2356   struct proc *p;
2357   int fd;
2358 
2359   if(proc == initproc)
2360     panic("init exiting");
2361 
2362   
2363   for(fd = 0; fd < NOFILE; fd++){
2364     if(proc->ofile[fd]){
2365       fileclose(proc->ofile[fd]);
2366       proc->ofile[fd] = 0;
2367     }
2368   }
2369 
2370   iput(proc->cwd);
2371   proc->cwd = 0;
2372 
2373   acquire(&ptable.lock);
2374 
2375   
2376   wakeup1(proc->parent);
2377 
2378   
2379   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2380     if(p->parent == proc){
2381       p->parent = initproc;
2382       if(p->state == ZOMBIE)
2383         wakeup1(initproc);
2384     }
2385   }
2386 
2387   
2388   proc->state = ZOMBIE;
2389   sched();
2390   panic("zombie exit");
2391 }
2392 
2393 
2394 
2395 
2396 
2397 
2398 
2399 
2400 
2401 
2402 int
2403 wait(void)
2404 {
2405   struct proc *p;
2406   int havekids, pid;
2407 
2408   acquire(&ptable.lock);
2409   for(;;){
2410     
2411     havekids = 0;
2412     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2413       if(p->parent != proc)
2414         continue;
2415       havekids = 1;
2416       if(p->state == ZOMBIE){
2417         
2418         pid = p->pid;
2419         kfree(p->kstack);
2420         p->kstack = 0;
2421         freevm(p->pgdir);
2422         p->state = UNUSED;
2423         p->pid = 0;
2424         p->parent = 0;
2425         p->name[0] = 0;
2426         p->killed = 0;
2427         release(&ptable.lock);
2428         return pid;
2429       }
2430     }
2431 
2432     
2433     if(!havekids || proc->killed){
2434       release(&ptable.lock);
2435       return -1;
2436     }
2437 
2438     
2439     sleep(proc, &ptable.lock);  
2440   }
2441 }
2442 
2443 
2444 
2445 
2446 
2447 
2448 
2449 
2450 
2451 
2452 
2453 
2454 
2455 
2456 
2457 void
2458 scheduler(void)
2459 {
2460   struct proc *p;
2461 
2462   for(;;){
2463     
2464     sti();
2465 
2466     
2467     acquire(&ptable.lock);
2468     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2469       if(p->state != RUNNABLE)
2470         continue;
2471 
2472       
2473       
2474       
2475       proc = p;
2476       switchuvm(p);
2477       p->state = RUNNING;
2478       swtch(&cpu->scheduler, proc->context);
2479       switchkvm();
2480 
2481       
2482       
2483       proc = 0;
2484     }
2485     release(&ptable.lock);
2486 
2487   }
2488 }
2489 
2490 
2491 
2492 
2493 
2494 
2495 
2496 
2497 
2498 
2499 
2500 
2501 
2502 void
2503 sched(void)
2504 {
2505   int intena;
2506 
2507   if(!holding(&ptable.lock))
2508     panic("sched ptable.lock");
2509   if(cpu->ncli != 1)
2510     panic("sched locks");
2511   if(proc->state == RUNNING)
2512     panic("sched running");
2513   if(readeflags()&FL_IF)
2514     panic("sched interruptible");
2515   intena = cpu->intena;
2516   swtch(&proc->context, cpu->scheduler);
2517   cpu->intena = intena;
2518 }
2519 
2520 
2521 void
2522 yield(void)
2523 {
2524   acquire(&ptable.lock);  
2525   proc->state = RUNNABLE;
2526   sched();
2527   release(&ptable.lock);
2528 }
2529 
2530 
2531 
2532 void
2533 forkret(void)
2534 {
2535   static int first = 1;
2536   
2537   release(&ptable.lock);
2538 
2539   if (first) {
2540     
2541     
2542     
2543     first = 0;
2544     initlog();
2545   }
2546 
2547   
2548 }
2549 
2550 
2551 
2552 void
2553 sleep(void *chan, struct spinlock *lk)
2554 {
2555   if(proc == 0)
2556     panic("sleep");
2557 
2558   if(lk == 0)
2559     panic("sleep without lk");
2560 
2561   
2562   
2563   
2564   
2565   
2566   
2567   if(lk != &ptable.lock){  
2568     acquire(&ptable.lock);  
2569     release(lk);
2570   }
2571 
2572   
2573   proc->chan = chan;
2574   proc->state = SLEEPING;
2575   sched();
2576 
2577   
2578   proc->chan = 0;
2579 
2580   
2581   if(lk != &ptable.lock){  
2582     release(&ptable.lock);
2583     acquire(lk);
2584   }
2585 }
2586 
2587 
2588 
2589 
2590 
2591 
2592 
2593 
2594 
2595 
2596 
2597 
2598 
2599 
2600 
2601 
2602 static void
2603 wakeup1(void *chan)
2604 {
2605   struct proc *p;
2606 
2607   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2608     if(p->state == SLEEPING && p->chan == chan)
2609       p->state = RUNNABLE;
2610 }
2611 
2612 
2613 void
2614 wakeup(void *chan)
2615 {
2616   acquire(&ptable.lock);
2617   wakeup1(chan);
2618   release(&ptable.lock);
2619 }
2620 
2621 
2622 
2623 
2624 int
2625 kill(int pid)
2626 {
2627   struct proc *p;
2628 
2629   acquire(&ptable.lock);
2630   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2631     if(p->pid == pid){
2632       p->killed = 1;
2633       
2634       if(p->state == SLEEPING)
2635         p->state = RUNNABLE;
2636       release(&ptable.lock);
2637       return 0;
2638     }
2639   }
2640   release(&ptable.lock);
2641   return -1;
2642 }
2643 
2644 
2645 
2646 
2647 
2648 
2649 
2650 
2651 
2652 
2653 void
2654 procdump(void)
2655 {
2656   static char *states[] = {
2657   [UNUSED]    "unused",
2658   [EMBRYO]    "embryo",
2659   [SLEEPING]  "sleep ",
2660   [RUNNABLE]  "runble",
2661   [RUNNING]   "run   ",
2662   [ZOMBIE]    "zombie"
2663   };
2664   int i;
2665   struct proc *p;
2666   char *state;
2667   uint pc[10];
2668 
2669   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2670     if(p->state == UNUSED)
2671       continue;
2672     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
2673       state = states[p->state];
2674     else
2675       state = "???";
2676     cprintf("%d %s %s", p->pid, state, p->name);
2677     if(p->state == SLEEPING){
2678       getcallerpcs((uint*)p->context->ebp+2, pc);
2679       for(i=0; i<10 && pc[i] != 0; i++)
2680         cprintf(" %p", pc[i]);
2681     }
2682     cprintf("\n");
2683   }
2684 }
2685 
2686 
2687 
2688 
2689 
2690 
2691 
2692 
2693 
2694 
2695 
2696 
2697 
2698 
2699 
2700 
2701 
2702 
2703 
2704 
2705 
2706 
2707 .globl swtch
2708 swtch:
2709   movl 4(%esp), %eax
2710   movl 8(%esp), %edx
2711 
2712   
2713   pushl %ebp
2714   pushl %ebx
2715   pushl %esi
2716   pushl %edi
2717 
2718   
2719   movl %esp, (%eax)
2720   movl %edx, %esp
2721 
2722   
2723   popl %edi
2724   popl %esi
2725   popl %ebx
2726   popl %ebp
2727   ret
2728 
2729 
2730 
2731 
2732 
2733 
2734 
2735 
2736 
2737 
2738 
2739 
2740 
2741 
2742 
2743 
2744 
2745 
2746 
2747 
2748 
2749 
2750 
2751 
2752 
2753 
2754 #include "types.h"
2755 #include "defs.h"
2756 #include "param.h"
2757 #include "memlayout.h"
2758 #include "mmu.h"
2759 #include "spinlock.h"
2760 
2761 void freerange(void *vstart, void *vend);
2762 extern char end[]; 
2763 
2764 struct run {
2765   struct run *next;
2766 };
2767 
2768 struct {
2769   struct spinlock lock;
2770   int use_lock;
2771   struct run *freelist;
2772 } kmem;
2773 
2774 
2775 
2776 
2777 
2778 
2779 void
2780 kinit1(void *vstart, void *vend)
2781 {
2782   initlock(&kmem.lock, "kmem");
2783   kmem.use_lock = 0;
2784   freerange(vstart, vend);
2785 }
2786 
2787 void
2788 kinit2(void *vstart, void *vend)
2789 {
2790   freerange(vstart, vend);
2791   kmem.use_lock = 1;
2792 }
2793 
2794 
2795 
2796 
2797 
2798 
2799 
2800 void
2801 freerange(void *vstart, void *vend)
2802 {
2803   char *p;
2804   p = (char*)PGROUNDUP((uint)vstart);
2805   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
2806     kfree(p);
2807 }
2808 
2809 
2810 
2811 
2812 
2813 
2814 void
2815 kfree(char *v)
2816 {
2817   struct run *r;
2818 
2819   if((uint)v % PGSIZE || v < end || v2p(v) >= PHYSTOP)
2820     panic("kfree");
2821 
2822   
2823   memset(v, 1, PGSIZE);
2824 
2825   if(kmem.use_lock)
2826     acquire(&kmem.lock);
2827   r = (struct run*)v;
2828   r->next = kmem.freelist;
2829   kmem.freelist = r;
2830   if(kmem.use_lock)
2831     release(&kmem.lock);
2832 }
2833 
2834 
2835 
2836 
2837 char*
2838 kalloc(void)
2839 {
2840   struct run *r;
2841 
2842   if(kmem.use_lock)
2843     acquire(&kmem.lock);
2844   r = kmem.freelist;
2845   if(r)
2846     kmem.freelist = r->next;
2847   if(kmem.use_lock)
2848     release(&kmem.lock);
2849   return (char*)r;
2850 }
2851 
2852 
2853 
2854 
2855 
2856 
2857 
2858 
2859 
2860 
2861 
2862 
2863 
2864 
2865 
2866 
2867 
2868 
2869 
2870 
2871 
2872 
2873 
2874 
2875 
2876 
2877 
2878 
2879 
2880 
2881 
2882 
2883 
2884 
2885 
2886 
2887 
2888 
2889 
2890 
2891 
2892 
2893 
2894 
2895 
2896 
2897 
2898 
2899 
2900 
2901 
2902 
2903 #define T_DIVIDE         0      
2904 #define T_DEBUG          1      
2905 #define T_NMI            2      
2906 #define T_BRKPT          3      
2907 #define T_OFLOW          4      
2908 #define T_BOUND          5      
2909 #define T_ILLOP          6      
2910 #define T_DEVICE         7      
2911 #define T_DBLFLT         8      
2912 
2913 #define T_TSS           10      
2914 #define T_SEGNP         11      
2915 #define T_STACK         12      
2916 #define T_GPFLT         13      
2917 #define T_PGFLT         14      
2918 
2919 #define T_FPERR         16      
2920 #define T_ALIGN         17      
2921 #define T_MCHK          18      
2922 #define T_SIMDERR       19      
2923 
2924 
2925 
2926 #define T_SYSCALL       64      
2927 #define T_DEFAULT      500      
2928 
2929 #define T_IRQ0          32      
2930 
2931 #define IRQ_TIMER        0
2932 #define IRQ_KBD          1
2933 #define IRQ_COM1         4
2934 #define IRQ_IDE         14
2935 #define IRQ_ERROR       19
2936 #define IRQ_SPURIOUS    31
2937 
2938 
2939 
2940 
2941 
2942 
2943 
2944 
2945 
2946 
2947 
2948 
2949 
2950 #!/usr/bin/perl -w
2951 
2952 # Generate vectors.S, the trap/interrupt entry points.
2953 # There has to be one entry point per interrupt number
2954 # since otherwise there's no way for trap() to discover
2955 # the interrupt number.
2956 
2957 print "# generated by vectors.pl - do not edit\n";
2958 print "# handlers\n";
2959 print ".globl alltraps\n";
2960 for(my $i = 0; $i < 256; $i++){
2961     print ".globl vector$i\n";
2962     print "vector$i:\n";
2963     if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
2964         print "  pushl \$0\n";
2965     }
2966     print "  pushl \$$i\n";
2967     print "  jmp alltraps\n";
2968 }
2969 
2970 print "\n# vector table\n";
2971 print ".data\n";
2972 print ".globl vectors\n";
2973 print "vectors:\n";
2974 for(my $i = 0; $i < 256; $i++){
2975     print "  .long vector$i\n";
2976 }
2977 
2978 # sample output:
2979 #   # handlers
2980 #   .globl alltraps
2981 #   .globl vector0
2982 #   vector0:
2983 #     pushl $0
2984 #     pushl $0
2985 #     jmp alltraps
2986 #   ...
2987 #
2988 #   # vector table
2989 #   .data
2990 #   .globl vectors
2991 #   vectors:
2992 #     .long vector0
2993 #     .long vector1
2994 #     .long vector2
2995 #   ...
2996 
2997 
2998 
2999 
3000 
3001 
3002   
3003 .globl alltraps
3004 alltraps:
3005   
3006   pushl %ds
3007   pushl %es
3008   pushl %fs
3009   pushl %gs
3010   pushal
3011 
3012   
3013   movw $(SEG_KDATA<<3), %ax
3014   movw %ax, %ds
3015   movw %ax, %es
3016   movw $(SEG_KCPU<<3), %ax
3017   movw %ax, %fs
3018   movw %ax, %gs
3019 
3020   
3021   pushl %esp
3022   call trap
3023   addl $4, %esp
3024 
3025   
3026 .globl trapret
3027 trapret:
3028   popal
3029   popl %gs
3030   popl %fs
3031   popl %es
3032   popl %ds
3033   addl $0x8, %esp  
3034   iret
3035 
3036 
3037 
3038 
3039 
3040 
3041 
3042 
3043 
3044 
3045 
3046 
3047 
3048 
3049 
3050 #include "types.h"
3051 #include "defs.h"
3052 #include "param.h"
3053 #include "memlayout.h"
3054 #include "mmu.h"
3055 #include "proc.h"
3056 #include "x86.h"
3057 #include "traps.h"
3058 #include "spinlock.h"
3059 
3060 
3061 struct gatedesc idt[256];
3062 extern uint vectors[];  
3063 struct spinlock tickslock;
3064 uint ticks;
3065 
3066 void
3067 tvinit(void)
3068 {
3069   int i;
3070 
3071   for(i = 0; i < 256; i++)
3072     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
3073   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
3074 
3075   initlock(&tickslock, "time");
3076 }
3077 
3078 void
3079 idtinit(void)
3080 {
3081   lidt(idt, sizeof(idt));
3082 }
3083 
3084 
3085 
3086 
3087 
3088 
3089 
3090 
3091 
3092 
3093 
3094 
3095 
3096 
3097 
3098 
3099 
3100 void
3101 trap(struct trapframe *tf)
3102 {
3103   if(tf->trapno == T_SYSCALL){
3104     if(proc->killed)
3105       exit();
3106     proc->tf = tf;
3107     syscall();
3108     if(proc->killed)
3109       exit();
3110     return;
3111   }
3112 
3113   switch(tf->trapno){
3114   case T_IRQ0 + IRQ_TIMER:
3115     if(cpu->id == 0){
3116       acquire(&tickslock);
3117       ticks++;
3118       wakeup(&ticks);
3119       release(&tickslock);
3120     }
3121     lapiceoi();
3122     break;
3123   case T_IRQ0 + IRQ_IDE:
3124     ideintr();
3125     lapiceoi();
3126     break;
3127   case T_IRQ0 + IRQ_IDE+1:
3128     
3129     break;
3130   case T_IRQ0 + IRQ_KBD:
3131     kbdintr();
3132     lapiceoi();
3133     break;
3134   case T_IRQ0 + IRQ_COM1:
3135     uartintr();
3136     lapiceoi();
3137     break;
3138   case T_IRQ0 + 7:
3139   case T_IRQ0 + IRQ_SPURIOUS:
3140     cprintf("cpu%d: spurious interrupt at %x:%x\n",
3141             cpu->id, tf->cs, tf->eip);
3142     lapiceoi();
3143     break;
3144 
3145 
3146 
3147 
3148 
3149 
3150   default:
3151     if(proc == 0 || (tf->cs&3) == 0){
3152       
3153       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
3154               tf->trapno, cpu->id, tf->eip, rcr2());
3155       panic("trap");
3156     }
3157     
3158     cprintf("pid %d %s: trap %d err %d on cpu %d "
3159             "eip 0x%x addr 0x%x--kill proc\n",
3160             proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip,
3161             rcr2());
3162     proc->killed = 1;
3163   }
3164 
3165   
3166   
3167   
3168   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
3169     exit();
3170 
3171   
3172   
3173   if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
3174     yield();
3175 
3176   
3177   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
3178     exit();
3179 }
3180 
3181 
3182 
3183 
3184 
3185 
3186 
3187 
3188 
3189 
3190 
3191 
3192 
3193 
3194 
3195 
3196 
3197 
3198 
3199 
3200 
3201 #define SYS_fork    1
3202 #define SYS_exit    2
3203 #define SYS_wait    3
3204 #define SYS_pipe    4
3205 #define SYS_read    5
3206 #define SYS_kill    6
3207 #define SYS_exec    7
3208 #define SYS_fstat   8
3209 #define SYS_chdir   9
3210 #define SYS_dup    10
3211 #define SYS_getpid 11
3212 #define SYS_sbrk   12
3213 #define SYS_sleep  13
3214 #define SYS_uptime 14
3215 #define SYS_open   15
3216 #define SYS_write  16
3217 #define SYS_mknod  17
3218 #define SYS_unlink 18
3219 #define SYS_link   19
3220 #define SYS_mkdir  20
3221 #define SYS_close  21
3222 #define SYS_test  22
3223 
3224 
3225 
3226 
3227 
3228 
3229 
3230 
3231 
3232 
3233 
3234 
3235 
3236 
3237 
3238 
3239 
3240 
3241 
3242 
3243 
3244 
3245 
3246 
3247 
3248 
3249 
3250 #include "types.h"
3251 #include "defs.h"
3252 #include "param.h"
3253 #include "memlayout.h"
3254 #include "mmu.h"
3255 #include "proc.h"
3256 #include "x86.h"
3257 #include "syscall.h"
3258 
3259 
3260 
3261 
3262 
3263 
3264 
3265 
3266 int
3267 fetchint(uint addr, int *ip)
3268 {
3269   if(addr >= proc->sz || addr+4 > proc->sz)
3270     return -1;
3271   *ip = *(int*)(addr);
3272   return 0;
3273 }
3274 
3275 
3276 
3277 
3278 int
3279 fetchstr(uint addr, char **pp)
3280 {
3281   char *s, *ep;
3282 
3283   if(addr >= proc->sz)
3284     return -1;
3285   *pp = (char*)addr;
3286   ep = (char*)proc->sz;
3287   for(s = *pp; s < ep; s++)
3288     if(*s == 0)
3289       return s - *pp;
3290   return -1;
3291 }
3292 
3293 
3294 int
3295 argint(int n, int *ip)
3296 {
3297   return fetchint(proc->tf->esp + 4 + 4*n, ip);
3298 }
3299 
3300 
3301 
3302 
3303 int
3304 argptr(int n, char **pp, int size)
3305 {
3306   int i;
3307 
3308   if(argint(n, &i) < 0)
3309     return -1;
3310   if((uint)i >= proc->sz || (uint)i+size > proc->sz)
3311     return -1;
3312   *pp = (char*)i;
3313   return 0;
3314 }
3315 
3316 
3317 
3318 
3319 
3320 int
3321 argstr(int n, char **pp)
3322 {
3323   int addr;
3324   if(argint(n, &addr) < 0)
3325     return -1;
3326   return fetchstr(addr, pp);
3327 }
3328 
3329 extern int sys_chdir(void);
3330 extern int sys_close(void);
3331 extern int sys_dup(void);
3332 extern int sys_exec(void);
3333 extern int sys_exit(void);
3334 extern int sys_fork(void);
3335 extern int sys_fstat(void);
3336 extern int sys_getpid(void);
3337 extern int sys_kill(void);
3338 extern int sys_link(void);
3339 extern int sys_mkdir(void);
3340 extern int sys_mknod(void);
3341 extern int sys_open(void);
3342 extern int sys_pipe(void);
3343 extern int sys_read(void);
3344 extern int sys_sbrk(void);
3345 extern int sys_sleep(void);
3346 extern int sys_unlink(void);
3347 extern int sys_wait(void);
3348 extern int sys_write(void);
3349 extern int sys_uptime(void);
3350 extern int sys_test(void);
3351 
3352 static int (*syscalls[])(void) = {
3353 [SYS_fork]    sys_fork,
3354 [SYS_exit]    sys_exit,
3355 [SYS_wait]    sys_wait,
3356 [SYS_pipe]    sys_pipe,
3357 [SYS_read]    sys_read,
3358 [SYS_kill]    sys_kill,
3359 [SYS_exec]    sys_exec,
3360 [SYS_fstat]   sys_fstat,
3361 [SYS_chdir]   sys_chdir,
3362 [SYS_dup]     sys_dup,
3363 [SYS_getpid]  sys_getpid,
3364 [SYS_sbrk]    sys_sbrk,
3365 [SYS_sleep]   sys_sleep,
3366 [SYS_uptime]  sys_uptime,
3367 [SYS_open]    sys_open,
3368 [SYS_write]   sys_write,
3369 [SYS_mknod]   sys_mknod,
3370 [SYS_unlink]  sys_unlink,
3371 [SYS_link]    sys_link,
3372 [SYS_mkdir]   sys_mkdir,
3373 [SYS_close]   sys_close,
3374 [SYS_test]   sys_test,
3375 };
3376 
3377 void
3378 syscall(void)
3379 {
3380   int num;
3381 
3382   num = proc->tf->eax;
3383   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
3384     proc->tf->eax = syscalls[num]();
3385   } else {
3386     cprintf("%d %s: unknown sys call %d\n",
3387             proc->pid, proc->name, num);
3388     proc->tf->eax = -1;
3389   }
3390 }
3391 
3392 
3393 
3394 
3395 
3396 
3397 
3398 
3399 
3400 #include "types.h"
3401 #include "x86.h"
3402 #include "defs.h"
3403 #include "param.h"
3404 #include "memlayout.h"
3405 #include "mmu.h"
3406 #include "proc.h"
3407 
3408 int
3409 sys_fork(void)
3410 {
3411   return fork();
3412 }
3413 
3414 int
3415 sys_exit(void)
3416 {
3417   exit();
3418   return 0;  
3419 }
3420 
3421 int
3422 sys_wait(void)
3423 {
3424   return wait();
3425 }
3426 
3427 int
3428 sys_kill(void)
3429 {
3430   int pid;
3431 
3432   if(argint(0, &pid) < 0)
3433     return -1;
3434   return kill(pid);
3435 }
3436 
3437 int
3438 sys_getpid(void)
3439 {
3440   return proc->pid;
3441 }
3442 
3443 
3444 
3445 
3446 
3447 
3448 
3449 
3450 int
3451 sys_sbrk(void)
3452 {
3453   int addr;
3454   int n;
3455 
3456   if(argint(0, &n) < 0)
3457     return -1;
3458   addr = proc->sz;
3459   if(growproc(n) < 0)
3460     return -1;
3461   return addr;
3462 }
3463 
3464 int
3465 sys_sleep(void)
3466 {
3467   int n;
3468   uint ticks0;
3469 
3470   if(argint(0, &n) < 0)
3471     return -1;
3472   acquire(&tickslock);
3473   ticks0 = ticks;
3474   while(ticks - ticks0 < n){
3475     if(proc->killed){
3476       release(&tickslock);
3477       return -1;
3478     }
3479     sleep(&ticks, &tickslock);
3480   }
3481   release(&tickslock);
3482   return 0;
3483 }
3484 
3485 
3486 
3487 int
3488 sys_uptime(void)
3489 {
3490   uint xticks;
3491 
3492   acquire(&tickslock);
3493   xticks = ticks;
3494   release(&tickslock);
3495   return xticks;
3496 }
3497 
3498 
3499 
3500 int
3501 sys_test(void)
3502 {
3503   cprintf("test syscall\n");
3504   return 0;
3505 }
3506 
3507 
3508 
3509 
3510 
3511 
3512 
3513 
3514 
3515 
3516 
3517 
3518 
3519 
3520 
3521 
3522 
3523 
3524 
3525 
3526 
3527 
3528 
3529 
3530 
3531 
3532 
3533 
3534 
3535 
3536 
3537 
3538 
3539 
3540 
3541 
3542 
3543 
3544 
3545 
3546 
3547 
3548 
3549 
3550 struct buf {
3551   int flags;
3552   uint dev;
3553   uint sector;
3554   struct buf *prev; 
3555   struct buf *next;
3556   struct buf *qnext; 
3557   uchar data[512];
3558 };
3559 #define B_BUSY  0x1  
3560 #define B_VALID 0x2  
3561 #define B_DIRTY 0x4  
3562 
3563 
3564 
3565 
3566 
3567 
3568 
3569 
3570 
3571 
3572 
3573 
3574 
3575 
3576 
3577 
3578 
3579 
3580 
3581 
3582 
3583 
3584 
3585 
3586 
3587 
3588 
3589 
3590 
3591 
3592 
3593 
3594 
3595 
3596 
3597 
3598 
3599 
3600 #define O_RDONLY  0x000
3601 #define O_WRONLY  0x001
3602 #define O_RDWR    0x002
3603 #define O_CREATE  0x200
3604 
3605 
3606 
3607 
3608 
3609 
3610 
3611 
3612 
3613 
3614 
3615 
3616 
3617 
3618 
3619 
3620 
3621 
3622 
3623 
3624 
3625 
3626 
3627 
3628 
3629 
3630 
3631 
3632 
3633 
3634 
3635 
3636 
3637 
3638 
3639 
3640 
3641 
3642 
3643 
3644 
3645 
3646 
3647 
3648 
3649 
3650 #define T_DIR  1   
3651 #define T_FILE 2   
3652 #define T_DEV  3   
3653 
3654 struct stat {
3655   short type;  
3656   int dev;     
3657   uint ino;    
3658   short nlink; 
3659   uint size;   
3660 };
3661 
3662 
3663 
3664 
3665 
3666 
3667 
3668 
3669 
3670 
3671 
3672 
3673 
3674 
3675 
3676 
3677 
3678 
3679 
3680 
3681 
3682 
3683 
3684 
3685 
3686 
3687 
3688 
3689 
3690 
3691 
3692 
3693 
3694 
3695 
3696 
3697 
3698 
3699 
3700 
3701 
3702 
3703 
3704 
3705 
3706 
3707 
3708 
3709 
3710 #define ROOTINO 1  
3711 #define BSIZE 512  
3712 
3713 
3714 struct superblock {
3715   uint size;         
3716   uint nblocks;      
3717   uint ninodes;      
3718   uint nlog;         
3719 };
3720 
3721 #define NDIRECT 12
3722 #define NINDIRECT (BSIZE / sizeof(uint))
3723 #define MAXFILE (NDIRECT + NINDIRECT)
3724 
3725 
3726 struct dinode {
3727   short type;           
3728   short major;          
3729   short minor;          
3730   short nlink;          
3731   uint size;            
3732   uint addrs[NDIRECT+1];   
3733 };
3734 
3735 
3736 #define IPB           (BSIZE / sizeof(struct dinode))
3737 
3738 
3739 #define IBLOCK(i)     ((i) / IPB + 2)
3740 
3741 
3742 #define BPB           (BSIZE*8)
3743 
3744 
3745 #define BBLOCK(b, ninodes) (b/BPB + (ninodes)/IPB + 3)
3746 
3747 
3748 #define DIRSIZ 14
3749 
3750 struct dirent {
3751   ushort inum;
3752   char name[DIRSIZ];
3753 };
3754 
3755 
3756 
3757 
3758 
3759 
3760 
3761 
3762 
3763 
3764 
3765 
3766 
3767 
3768 
3769 
3770 
3771 
3772 
3773 
3774 
3775 
3776 
3777 
3778 
3779 
3780 
3781 
3782 
3783 
3784 
3785 
3786 
3787 
3788 
3789 
3790 
3791 
3792 
3793 
3794 
3795 
3796 
3797 
3798 
3799 
3800 struct file {
3801   enum { FD_NONE, FD_PIPE, FD_INODE } type;
3802   int ref; 
3803   char readable;
3804   char writable;
3805   struct pipe *pipe;
3806   struct inode *ip;
3807   uint off;
3808 };
3809 
3810 
3811 
3812 struct inode {
3813   uint dev;           
3814   uint inum;          
3815   int ref;            
3816   int flags;          
3817 
3818   short type;         
3819   short major;
3820   short minor;
3821   short nlink;
3822   uint size;
3823   uint addrs[NDIRECT+1];
3824 };
3825 #define I_BUSY 0x1
3826 #define I_VALID 0x2
3827 
3828 
3829 
3830 struct devsw {
3831   int (*read)(struct inode*, char*, int);
3832   int (*write)(struct inode*, char*, int);
3833 };
3834 
3835 extern struct devsw devsw[];
3836 
3837 #define CONSOLE 1
3838 
3839 
3840 
3841 
3842 
3843 
3844 
3845 
3846 
3847 
3848 
3849 
3850 
3851 
3852 #include "types.h"
3853 #include "defs.h"
3854 #include "param.h"
3855 #include "memlayout.h"
3856 #include "mmu.h"
3857 #include "proc.h"
3858 #include "x86.h"
3859 #include "traps.h"
3860 #include "spinlock.h"
3861 #include "buf.h"
3862 
3863 #define IDE_BSY       0x80
3864 #define IDE_DRDY      0x40
3865 #define IDE_DF        0x20
3866 #define IDE_ERR       0x01
3867 
3868 #define IDE_CMD_READ  0x20
3869 #define IDE_CMD_WRITE 0x30
3870 
3871 
3872 
3873 
3874 
3875 static struct spinlock idelock;
3876 static struct buf *idequeue;
3877 
3878 static int havedisk1;
3879 static void idestart(struct buf*);
3880 
3881 
3882 static int
3883 idewait(int checkerr)
3884 {
3885   int r;
3886 
3887   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
3888     ;
3889   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
3890     return -1;
3891   return 0;
3892 }
3893 
3894 
3895 
3896 
3897 
3898 
3899 
3900 void
3901 ideinit(void)
3902 {
3903   int i;
3904 
3905   initlock(&idelock, "ide");
3906   picenable(IRQ_IDE);
3907   ioapicenable(IRQ_IDE, ncpu - 1);
3908   idewait(0);
3909 
3910   
3911   outb(0x1f6, 0xe0 | (1<<4));
3912   for(i=0; i<1000; i++){
3913     if(inb(0x1f7) != 0){
3914       havedisk1 = 1;
3915       break;
3916     }
3917   }
3918 
3919   
3920   outb(0x1f6, 0xe0 | (0<<4));
3921 }
3922 
3923 
3924 static void
3925 idestart(struct buf *b)
3926 {
3927   if(b == 0)
3928     panic("idestart");
3929 
3930   idewait(0);
3931   outb(0x3f6, 0);  
3932   outb(0x1f2, 1);  
3933   outb(0x1f3, b->sector & 0xff);
3934   outb(0x1f4, (b->sector >> 8) & 0xff);
3935   outb(0x1f5, (b->sector >> 16) & 0xff);
3936   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((b->sector>>24)&0x0f));
3937   if(b->flags & B_DIRTY){
3938     outb(0x1f7, IDE_CMD_WRITE);
3939     outsl(0x1f0, b->data, 512/4);
3940   } else {
3941     outb(0x1f7, IDE_CMD_READ);
3942   }
3943 }
3944 
3945 
3946 
3947 
3948 
3949 
3950 
3951 void
3952 ideintr(void)
3953 {
3954   struct buf *b;
3955 
3956   
3957   acquire(&idelock);
3958   if((b = idequeue) == 0){
3959     release(&idelock);
3960     
3961     return;
3962   }
3963   idequeue = b->qnext;
3964 
3965   
3966   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
3967     insl(0x1f0, b->data, 512/4);
3968 
3969   
3970   b->flags |= B_VALID;
3971   b->flags &= ~B_DIRTY;
3972   wakeup(b);
3973 
3974   
3975   if(idequeue != 0)
3976     idestart(idequeue);
3977 
3978   release(&idelock);
3979 }
3980 
3981 
3982 
3983 
3984 
3985 
3986 
3987 
3988 
3989 
3990 
3991 
3992 
3993 
3994 
3995 
3996 
3997 
3998 
3999 
4000 
4001 
4002 
4003 void
4004 iderw(struct buf *b)
4005 {
4006   struct buf **pp;
4007 
4008   if(!(b->flags & B_BUSY))
4009     panic("iderw: buf not busy");
4010   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
4011     panic("iderw: nothing to do");
4012   if(b->dev != 0 && !havedisk1)
4013     panic("iderw: ide disk 1 not present");
4014 
4015   acquire(&idelock);  
4016 
4017   
4018   b->qnext = 0;
4019   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  
4020     ;
4021   *pp = b;
4022 
4023   
4024   if(idequeue == b)
4025     idestart(b);
4026 
4027   
4028   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
4029     sleep(b, &idelock);
4030   }
4031 
4032   release(&idelock);
4033 }
4034 
4035 
4036 
4037 
4038 
4039 
4040 
4041 
4042 
4043 
4044 
4045 
4046 
4047 
4048 
4049 
4050 
4051 
4052 
4053 
4054 
4055 
4056 
4057 
4058 
4059 
4060 
4061 
4062 
4063 
4064 
4065 
4066 
4067 
4068 
4069 
4070 
4071 
4072 #include "types.h"
4073 #include "defs.h"
4074 #include "param.h"
4075 #include "spinlock.h"
4076 #include "buf.h"
4077 
4078 struct {
4079   struct spinlock lock;
4080   struct buf buf[NBUF];
4081 
4082   
4083   
4084   struct buf head;
4085 } bcache;
4086 
4087 void
4088 binit(void)
4089 {
4090   struct buf *b;
4091 
4092   initlock(&bcache.lock, "bcache");
4093 
4094 
4095 
4096 
4097 
4098 
4099 
4100   
4101   bcache.head.prev = &bcache.head;
4102   bcache.head.next = &bcache.head;
4103   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
4104     b->next = bcache.head.next;
4105     b->prev = &bcache.head;
4106     b->dev = -1;
4107     bcache.head.next->prev = b;
4108     bcache.head.next = b;
4109   }
4110 }
4111 
4112 
4113 
4114 
4115 static struct buf*
4116 bget(uint dev, uint sector)
4117 {
4118   struct buf *b;
4119 
4120   acquire(&bcache.lock);
4121 
4122  loop:
4123   
4124   for(b = bcache.head.next; b != &bcache.head; b = b->next){
4125     if(b->dev == dev && b->sector == sector){
4126       if(!(b->flags & B_BUSY)){
4127         b->flags |= B_BUSY;
4128         release(&bcache.lock);
4129         return b;
4130       }
4131       sleep(b, &bcache.lock);
4132       goto loop;
4133     }
4134   }
4135 
4136   
4137   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
4138     if((b->flags & B_BUSY) == 0 && (b->flags & B_DIRTY) == 0){
4139       b->dev = dev;
4140       b->sector = sector;
4141       b->flags = B_BUSY;
4142       release(&bcache.lock);
4143       return b;
4144     }
4145   }
4146   panic("bget: no buffers");
4147 }
4148 
4149 
4150 
4151 struct buf*
4152 bread(uint dev, uint sector)
4153 {
4154   struct buf *b;
4155 
4156   b = bget(dev, sector);
4157   if(!(b->flags & B_VALID))
4158     iderw(b);
4159   return b;
4160 }
4161 
4162 
4163 void
4164 bwrite(struct buf *b)
4165 {
4166   if((b->flags & B_BUSY) == 0)
4167     panic("bwrite");
4168   b->flags |= B_DIRTY;
4169   iderw(b);
4170 }
4171 
4172 
4173 
4174 void
4175 brelse(struct buf *b)
4176 {
4177   if((b->flags & B_BUSY) == 0)
4178     panic("brelse");
4179 
4180   acquire(&bcache.lock);
4181 
4182   b->next->prev = b->prev;
4183   b->prev->next = b->next;
4184   b->next = bcache.head.next;
4185   b->prev = &bcache.head;
4186   bcache.head.next->prev = b;
4187   bcache.head.next = b;
4188 
4189   b->flags &= ~B_BUSY;
4190   wakeup(b);
4191 
4192   release(&bcache.lock);
4193 }
4194 
4195 
4196 
4197 
4198 
4199 
4200 #include "types.h"
4201 #include "defs.h"
4202 #include "param.h"
4203 #include "spinlock.h"
4204 #include "fs.h"
4205 #include "buf.h"
4206 
4207 
4208 
4209 
4210 
4211 
4212 
4213 
4214 
4215 
4216 
4217 
4218 
4219 
4220 
4221 
4222 
4223 
4224 
4225 
4226 
4227 
4228 
4229 
4230 
4231 
4232 
4233 
4234 
4235 struct logheader {
4236   int n;
4237   int sector[LOGSIZE];
4238 };
4239 
4240 struct log {
4241   struct spinlock lock;
4242   int start;
4243   int size;
4244   int busy; 
4245   int dev;
4246   struct logheader lh;
4247 };
4248 
4249 
4250 struct log log;
4251 
4252 static void recover_from_log(void);
4253 
4254 void
4255 initlog(void)
4256 {
4257   if (sizeof(struct logheader) >= BSIZE)
4258     panic("initlog: too big logheader");
4259 
4260   struct superblock sb;
4261   initlock(&log.lock, "log");
4262   readsb(ROOTDEV, &sb);
4263   log.start = sb.size - sb.nlog;
4264   log.size = sb.nlog;
4265   log.dev = ROOTDEV;
4266   recover_from_log();
4267 }
4268 
4269 
4270 static void
4271 install_trans(void)
4272 {
4273   int tail;
4274 
4275   for (tail = 0; tail < log.lh.n; tail++) {
4276     struct buf *lbuf = bread(log.dev, log.start+tail+1); 
4277     struct buf *dbuf = bread(log.dev, log.lh.sector[tail]); 
4278     memmove(dbuf->data, lbuf->data, BSIZE);  
4279     bwrite(dbuf);  
4280     brelse(lbuf);
4281     brelse(dbuf);
4282   }
4283 }
4284 
4285 
4286 static void
4287 read_head(void)
4288 {
4289   struct buf *buf = bread(log.dev, log.start);
4290   struct logheader *lh = (struct logheader *) (buf->data);
4291   int i;
4292   log.lh.n = lh->n;
4293   for (i = 0; i < log.lh.n; i++) {
4294     log.lh.sector[i] = lh->sector[i];
4295   }
4296   brelse(buf);
4297 }
4298 
4299 
4300 
4301 
4302 
4303 static void
4304 write_head(void)
4305 {
4306   struct buf *buf = bread(log.dev, log.start);
4307   struct logheader *hb = (struct logheader *) (buf->data);
4308   int i;
4309   hb->n = log.lh.n;
4310   for (i = 0; i < log.lh.n; i++) {
4311     hb->sector[i] = log.lh.sector[i];
4312   }
4313   bwrite(buf);
4314   brelse(buf);
4315 }
4316 
4317 static void
4318 recover_from_log(void)
4319 {
4320   read_head();
4321   install_trans(); 
4322   log.lh.n = 0;
4323   write_head(); 
4324 }
4325 
4326 void
4327 begin_trans(void)
4328 {
4329   acquire(&log.lock);
4330   while (log.busy) {
4331     sleep(&log, &log.lock);
4332   }
4333   log.busy = 1;
4334   release(&log.lock);
4335 }
4336 
4337 
4338 
4339 
4340 
4341 
4342 
4343 
4344 
4345 
4346 
4347 
4348 
4349 
4350 void
4351 commit_trans(void)
4352 {
4353   if (log.lh.n > 0) {
4354     write_head();    
4355     install_trans(); 
4356     log.lh.n = 0;
4357     write_head();    
4358   }
4359 
4360   acquire(&log.lock);
4361   log.busy = 0;
4362   wakeup(&log);
4363   release(&log.lock);
4364 }
4365 
4366 
4367 
4368 
4369 
4370 
4371 
4372 
4373 
4374 void
4375 log_write(struct buf *b)
4376 {
4377   int i;
4378 
4379   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
4380     panic("too big a transaction");
4381   if (!log.busy)
4382     panic("write outside of trans");
4383 
4384   for (i = 0; i < log.lh.n; i++) {
4385     if (log.lh.sector[i] == b->sector)   
4386       break;
4387   }
4388   log.lh.sector[i] = b->sector;
4389   struct buf *lbuf = bread(b->dev, log.start+i+1);
4390   memmove(lbuf->data, b->data, BSIZE);
4391   bwrite(lbuf);
4392   brelse(lbuf);
4393   if (i == log.lh.n)
4394     log.lh.n++;
4395   b->flags |= B_DIRTY; 
4396 }
4397 
4398 
4399 
4400 
4401 
4402 
4403 
4404 
4405 
4406 
4407 
4408 
4409 
4410 
4411 
4412 
4413 
4414 
4415 
4416 
4417 
4418 
4419 
4420 
4421 
4422 
4423 
4424 
4425 
4426 
4427 
4428 
4429 
4430 
4431 
4432 
4433 
4434 
4435 
4436 
4437 
4438 
4439 
4440 
4441 
4442 
4443 
4444 
4445 
4446 
4447 
4448 
4449 
4450 
4451 
4452 
4453 
4454 
4455 
4456 
4457 
4458 
4459 
4460 
4461 #include "types.h"
4462 #include "defs.h"
4463 #include "param.h"
4464 #include "stat.h"
4465 #include "mmu.h"
4466 #include "proc.h"
4467 #include "spinlock.h"
4468 #include "buf.h"
4469 #include "fs.h"
4470 #include "file.h"
4471 
4472 #define min(a, b) ((a) < (b) ? (a) : (b))
4473 static void itrunc(struct inode*);
4474 
4475 
4476 void
4477 readsb(int dev, struct superblock *sb)
4478 {
4479   struct buf *bp;
4480 
4481   bp = bread(dev, 1);
4482   memmove(sb, bp->data, sizeof(*sb));
4483   brelse(bp);
4484 }
4485 
4486 
4487 static void
4488 bzero(int dev, int bno)
4489 {
4490   struct buf *bp;
4491 
4492   bp = bread(dev, bno);
4493   memset(bp->data, 0, BSIZE);
4494   log_write(bp);
4495   brelse(bp);
4496 }
4497 
4498 
4499 
4500 
4501 
4502 
4503 static uint
4504 balloc(uint dev)
4505 {
4506   int b, bi, m;
4507   struct buf *bp;
4508   struct superblock sb;
4509 
4510   bp = 0;
4511   readsb(dev, &sb);
4512   for(b = 0; b < sb.size; b += BPB){
4513     bp = bread(dev, BBLOCK(b, sb.ninodes));
4514     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
4515       m = 1 << (bi % 8);
4516       if((bp->data[bi/8] & m) == 0){  
4517         bp->data[bi/8] |= m;  
4518         log_write(bp);
4519         brelse(bp);
4520         bzero(dev, b + bi);
4521         return b + bi;
4522       }
4523     }
4524     brelse(bp);
4525   }
4526   panic("balloc: out of blocks");
4527 }
4528 
4529 
4530 static void
4531 bfree(int dev, uint b)
4532 {
4533   struct buf *bp;
4534   struct superblock sb;
4535   int bi, m;
4536 
4537   readsb(dev, &sb);
4538   bp = bread(dev, BBLOCK(b, sb.ninodes));
4539   bi = b % BPB;
4540   m = 1 << (bi % 8);
4541   if((bp->data[bi/8] & m) == 0)
4542     panic("freeing free block");
4543   bp->data[bi/8] &= ~m;
4544   log_write(bp);
4545   brelse(bp);
4546 }
4547 
4548 
4549 
4550 
4551 
4552 
4553 
4554 
4555 
4556 
4557 
4558 
4559 
4560 
4561 
4562 
4563 
4564 
4565 
4566 
4567 
4568 
4569 
4570 
4571 
4572 
4573 
4574 
4575 
4576 
4577 
4578 
4579 
4580 
4581 
4582 
4583 
4584 
4585 
4586 
4587 
4588 
4589 
4590 
4591 
4592 
4593 
4594 
4595 
4596 
4597 
4598 
4599 
4600 
4601 
4602 
4603 
4604 
4605 
4606 
4607 
4608 
4609 
4610 
4611 
4612 struct {
4613   struct spinlock lock;
4614   struct inode inode[NINODE];
4615 } icache;
4616 
4617 void
4618 iinit(void)
4619 {
4620   initlock(&icache.lock, "icache");
4621 }
4622 
4623 static struct inode* iget(uint dev, uint inum);
4624 
4625 
4626 
4627 
4628 
4629 
4630 
4631 
4632 
4633 
4634 
4635 
4636 
4637 
4638 
4639 
4640 
4641 
4642 
4643 
4644 
4645 
4646 
4647 
4648 
4649 
4650 
4651 
4652 struct inode*
4653 ialloc(uint dev, short type)
4654 {
4655   int inum;
4656   struct buf *bp;
4657   struct dinode *dip;
4658   struct superblock sb;
4659 
4660   readsb(dev, &sb);
4661 
4662   for(inum = 1; inum < sb.ninodes; inum++){
4663     bp = bread(dev, IBLOCK(inum));
4664     dip = (struct dinode*)bp->data + inum%IPB;
4665     if(dip->type == 0){  
4666       memset(dip, 0, sizeof(*dip));
4667       dip->type = type;
4668       log_write(bp);   
4669       brelse(bp);
4670       return iget(dev, inum);
4671     }
4672     brelse(bp);
4673   }
4674   panic("ialloc: no inodes");
4675 }
4676 
4677 
4678 void
4679 iupdate(struct inode *ip)
4680 {
4681   struct buf *bp;
4682   struct dinode *dip;
4683 
4684   bp = bread(ip->dev, IBLOCK(ip->inum));
4685   dip = (struct dinode*)bp->data + ip->inum%IPB;
4686   dip->type = ip->type;
4687   dip->major = ip->major;
4688   dip->minor = ip->minor;
4689   dip->nlink = ip->nlink;
4690   dip->size = ip->size;
4691   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
4692   log_write(bp);
4693   brelse(bp);
4694 }
4695 
4696 
4697 
4698 
4699 
4700 
4701 
4702 
4703 static struct inode*
4704 iget(uint dev, uint inum)
4705 {
4706   struct inode *ip, *empty;
4707 
4708   acquire(&icache.lock);
4709 
4710   
4711   empty = 0;
4712   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
4713     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
4714       ip->ref++;
4715       release(&icache.lock);
4716       return ip;
4717     }
4718     if(empty == 0 && ip->ref == 0)    
4719       empty = ip;
4720   }
4721 
4722   
4723   if(empty == 0)
4724     panic("iget: no inodes");
4725 
4726   ip = empty;
4727   ip->dev = dev;
4728   ip->inum = inum;
4729   ip->ref = 1;
4730   ip->flags = 0;
4731   release(&icache.lock);
4732 
4733   return ip;
4734 }
4735 
4736 
4737 
4738 struct inode*
4739 idup(struct inode *ip)
4740 {
4741   acquire(&icache.lock);
4742   ip->ref++;
4743   release(&icache.lock);
4744   return ip;
4745 }
4746 
4747 
4748 
4749 
4750 
4751 
4752 void
4753 ilock(struct inode *ip)
4754 {
4755   struct buf *bp;
4756   struct dinode *dip;
4757 
4758   if(ip == 0 || ip->ref < 1)
4759     panic("ilock");
4760 
4761   acquire(&icache.lock);
4762   while(ip->flags & I_BUSY)
4763     sleep(ip, &icache.lock);
4764   ip->flags |= I_BUSY;
4765   release(&icache.lock);
4766 
4767   if(!(ip->flags & I_VALID)){
4768     bp = bread(ip->dev, IBLOCK(ip->inum));
4769     dip = (struct dinode*)bp->data + ip->inum%IPB;
4770     ip->type = dip->type;
4771     ip->major = dip->major;
4772     ip->minor = dip->minor;
4773     ip->nlink = dip->nlink;
4774     ip->size = dip->size;
4775     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
4776     brelse(bp);
4777     ip->flags |= I_VALID;
4778     if(ip->type == 0)
4779       panic("ilock: no type");
4780   }
4781 }
4782 
4783 
4784 void
4785 iunlock(struct inode *ip)
4786 {
4787   if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
4788     panic("iunlock");
4789 
4790   acquire(&icache.lock);
4791   ip->flags &= ~I_BUSY;
4792   wakeup(ip);
4793   release(&icache.lock);
4794 }
4795 
4796 
4797 
4798 
4799 
4800 
4801 
4802 
4803 
4804 
4805 void
4806 iput(struct inode *ip)
4807 {
4808   acquire(&icache.lock);
4809   if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
4810     
4811     if(ip->flags & I_BUSY)
4812       panic("iput busy");
4813     ip->flags |= I_BUSY;
4814     release(&icache.lock);
4815     itrunc(ip);
4816     ip->type = 0;
4817     iupdate(ip);
4818     acquire(&icache.lock);
4819     ip->flags = 0;
4820     wakeup(ip);
4821   }
4822   ip->ref--;
4823   release(&icache.lock);
4824 }
4825 
4826 
4827 void
4828 iunlockput(struct inode *ip)
4829 {
4830   iunlock(ip);
4831   iput(ip);
4832 }
4833 
4834 
4835 
4836 
4837 
4838 
4839 
4840 
4841 
4842 
4843 
4844 
4845 
4846 
4847 
4848 
4849 
4850 
4851 
4852 
4853 
4854 
4855 
4856 
4857 
4858 
4859 static uint
4860 bmap(struct inode *ip, uint bn)
4861 {
4862   uint addr, *a;
4863   struct buf *bp;
4864 
4865   if(bn < NDIRECT){
4866     if((addr = ip->addrs[bn]) == 0)
4867       ip->addrs[bn] = addr = balloc(ip->dev);
4868     return addr;
4869   }
4870   bn -= NDIRECT;
4871 
4872   if(bn < NINDIRECT){
4873     
4874     if((addr = ip->addrs[NDIRECT]) == 0)
4875       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
4876     bp = bread(ip->dev, addr);
4877     a = (uint*)bp->data;
4878     if((addr = a[bn]) == 0){
4879       a[bn] = addr = balloc(ip->dev);
4880       log_write(bp);
4881     }
4882     brelse(bp);
4883     return addr;
4884   }
4885 
4886   panic("bmap: out of range");
4887 }
4888 
4889 
4890 
4891 
4892 
4893 
4894 
4895 
4896 
4897 
4898 
4899 
4900 
4901 
4902 
4903 
4904 
4905 static void
4906 itrunc(struct inode *ip)
4907 {
4908   int i, j;
4909   struct buf *bp;
4910   uint *a;
4911 
4912   for(i = 0; i < NDIRECT; i++){
4913     if(ip->addrs[i]){
4914       bfree(ip->dev, ip->addrs[i]);
4915       ip->addrs[i] = 0;
4916     }
4917   }
4918 
4919   if(ip->addrs[NDIRECT]){
4920     bp = bread(ip->dev, ip->addrs[NDIRECT]);
4921     a = (uint*)bp->data;
4922     for(j = 0; j < NINDIRECT; j++){
4923       if(a[j])
4924         bfree(ip->dev, a[j]);
4925     }
4926     brelse(bp);
4927     bfree(ip->dev, ip->addrs[NDIRECT]);
4928     ip->addrs[NDIRECT] = 0;
4929   }
4930 
4931   ip->size = 0;
4932   iupdate(ip);
4933 }
4934 
4935 
4936 void
4937 stati(struct inode *ip, struct stat *st)
4938 {
4939   st->dev = ip->dev;
4940   st->ino = ip->inum;
4941   st->type = ip->type;
4942   st->nlink = ip->nlink;
4943   st->size = ip->size;
4944 }
4945 
4946 
4947 
4948 
4949 
4950 
4951 int
4952 readi(struct inode *ip, char *dst, uint off, uint n)
4953 {
4954   uint tot, m;
4955   struct buf *bp;
4956 
4957   if(ip->type == T_DEV){
4958     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
4959       return -1;
4960     return devsw[ip->major].read(ip, dst, n);
4961   }
4962 
4963   if(off > ip->size || off + n < off)
4964     return -1;
4965   if(off + n > ip->size)
4966     n = ip->size - off;
4967 
4968   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
4969     bp = bread(ip->dev, bmap(ip, off/BSIZE));
4970     m = min(n - tot, BSIZE - off%BSIZE);
4971     memmove(dst, bp->data + off%BSIZE, m);
4972     brelse(bp);
4973   }
4974   return n;
4975 }
4976 
4977 
4978 
4979 
4980 
4981 
4982 
4983 
4984 
4985 
4986 
4987 
4988 
4989 
4990 
4991 
4992 
4993 
4994 
4995 
4996 
4997 
4998 
4999 
5000 
5001 int
5002 writei(struct inode *ip, char *src, uint off, uint n)
5003 {
5004   uint tot, m;
5005   struct buf *bp;
5006 
5007   if(ip->type == T_DEV){
5008     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
5009       return -1;
5010     return devsw[ip->major].write(ip, src, n);
5011   }
5012 
5013   if(off > ip->size || off + n < off)
5014     return -1;
5015   if(off + n > MAXFILE*BSIZE)
5016     return -1;
5017 
5018   for(tot=0; tot<n; tot+=m, off+=m, src+=m){
5019     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5020     m = min(n - tot, BSIZE - off%BSIZE);
5021     memmove(bp->data + off%BSIZE, src, m);
5022     log_write(bp);
5023     brelse(bp);
5024   }
5025 
5026   if(n > 0 && off > ip->size){
5027     ip->size = off;
5028     iupdate(ip);
5029   }
5030   return n;
5031 }
5032 
5033 
5034 
5035 
5036 
5037 
5038 
5039 
5040 
5041 
5042 
5043 
5044 
5045 
5046 
5047 
5048 
5049 
5050 
5051 
5052 int
5053 namecmp(const char *s, const char *t)
5054 {
5055   return strncmp(s, t, DIRSIZ);
5056 }
5057 
5058 
5059 
5060 struct inode*
5061 dirlookup(struct inode *dp, char *name, uint *poff)
5062 {
5063   uint off, inum;
5064   struct dirent de;
5065 
5066   if(dp->type != T_DIR)
5067     panic("dirlookup not DIR");
5068 
5069   for(off = 0; off < dp->size; off += sizeof(de)){
5070     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5071       panic("dirlink read");
5072     if(de.inum == 0)
5073       continue;
5074     if(namecmp(name, de.name) == 0){
5075       
5076       if(poff)
5077         *poff = off;
5078       inum = de.inum;
5079       return iget(dp->dev, inum);
5080     }
5081   }
5082 
5083   return 0;
5084 }
5085 
5086 
5087 
5088 
5089 
5090 
5091 
5092 
5093 
5094 
5095 
5096 
5097 
5098 
5099 
5100 
5101 int
5102 dirlink(struct inode *dp, char *name, uint inum)
5103 {
5104   int off;
5105   struct dirent de;
5106   struct inode *ip;
5107 
5108   
5109   if((ip = dirlookup(dp, name, 0)) != 0){
5110     iput(ip);
5111     return -1;
5112   }
5113 
5114   
5115   for(off = 0; off < dp->size; off += sizeof(de)){
5116     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5117       panic("dirlink read");
5118     if(de.inum == 0)
5119       break;
5120   }
5121 
5122   strncpy(de.name, name, DIRSIZ);
5123   de.inum = inum;
5124   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5125     panic("dirlink");
5126 
5127   return 0;
5128 }
5129 
5130 
5131 
5132 
5133 
5134 
5135 
5136 
5137 
5138 
5139 
5140 
5141 
5142 
5143 
5144 
5145 
5146 
5147 
5148 
5149 
5150 
5151 
5152 
5153 
5154 
5155 
5156 
5157 
5158 
5159 
5160 
5161 
5162 
5163 
5164 static char*
5165 skipelem(char *path, char *name)
5166 {
5167   char *s;
5168   int len;
5169 
5170   while(*path == '/')
5171     path++;
5172   if(*path == 0)
5173     return 0;
5174   s = path;
5175   while(*path != '/' && *path != 0)
5176     path++;
5177   len = path - s;
5178   if(len >= DIRSIZ)
5179     memmove(name, s, DIRSIZ);
5180   else {
5181     memmove(name, s, len);
5182     name[len] = 0;
5183   }
5184   while(*path == '/')
5185     path++;
5186   return path;
5187 }
5188 
5189 
5190 
5191 
5192 
5193 
5194 
5195 
5196 
5197 
5198 
5199 
5200 
5201 
5202 
5203 static struct inode*
5204 namex(char *path, int nameiparent, char *name)
5205 {
5206   struct inode *ip, *next;
5207 
5208   if(*path == '/')
5209     ip = iget(ROOTDEV, ROOTINO);
5210   else
5211     ip = idup(proc->cwd);
5212 
5213   while((path = skipelem(path, name)) != 0){
5214     ilock(ip);
5215     if(ip->type != T_DIR){
5216       iunlockput(ip);
5217       return 0;
5218     }
5219     if(nameiparent && *path == '\0'){
5220       
5221       iunlock(ip);
5222       return ip;
5223     }
5224     if((next = dirlookup(ip, name, 0)) == 0){
5225       iunlockput(ip);
5226       return 0;
5227     }
5228     iunlockput(ip);
5229     ip = next;
5230   }
5231   if(nameiparent){
5232     iput(ip);
5233     return 0;
5234   }
5235   return ip;
5236 }
5237 
5238 struct inode*
5239 namei(char *path)
5240 {
5241   char name[DIRSIZ];
5242   return namex(path, 0, name);
5243 }
5244 
5245 struct inode*
5246 nameiparent(char *path, char *name)
5247 {
5248   return namex(path, 1, name);
5249 }
5250 
5251 
5252 
5253 
5254 #include "types.h"
5255 #include "defs.h"
5256 #include "param.h"
5257 #include "fs.h"
5258 #include "file.h"
5259 #include "spinlock.h"
5260 
5261 struct devsw devsw[NDEV];
5262 struct {
5263   struct spinlock lock;
5264   struct file file[NFILE];
5265 } ftable;
5266 
5267 void
5268 fileinit(void)
5269 {
5270   initlock(&ftable.lock, "ftable");
5271 }
5272 
5273 
5274 struct file*
5275 filealloc(void)
5276 {
5277   struct file *f;
5278 
5279   acquire(&ftable.lock);
5280   for(f = ftable.file; f < ftable.file + NFILE; f++){
5281     if(f->ref == 0){
5282       f->ref = 1;
5283       release(&ftable.lock);
5284       return f;
5285     }
5286   }
5287   release(&ftable.lock);
5288   return 0;
5289 }
5290 
5291 
5292 
5293 
5294 
5295 
5296 
5297 
5298 
5299 
5300 
5301 struct file*
5302 filedup(struct file *f)
5303 {
5304   acquire(&ftable.lock);
5305   if(f->ref < 1)
5306     panic("filedup");
5307   f->ref++;
5308   release(&ftable.lock);
5309   return f;
5310 }
5311 
5312 
5313 void
5314 fileclose(struct file *f)
5315 {
5316   struct file ff;
5317 
5318   acquire(&ftable.lock);
5319   if(f->ref < 1)
5320     panic("fileclose");
5321   if(--f->ref > 0){
5322     release(&ftable.lock);
5323     return;
5324   }
5325   ff = *f;
5326   f->ref = 0;
5327   f->type = FD_NONE;
5328   release(&ftable.lock);
5329 
5330   if(ff.type == FD_PIPE)
5331     pipeclose(ff.pipe, ff.writable);
5332   else if(ff.type == FD_INODE){
5333     begin_trans();
5334     iput(ff.ip);
5335     commit_trans();
5336   }
5337 }
5338 
5339 
5340 
5341 
5342 
5343 
5344 
5345 
5346 
5347 
5348 
5349 
5350 
5351 int
5352 filestat(struct file *f, struct stat *st)
5353 {
5354   if(f->type == FD_INODE){
5355     ilock(f->ip);
5356     stati(f->ip, st);
5357     iunlock(f->ip);
5358     return 0;
5359   }
5360   return -1;
5361 }
5362 
5363 
5364 int
5365 fileread(struct file *f, char *addr, int n)
5366 {
5367   int r;
5368 
5369   if(f->readable == 0)
5370     return -1;
5371   if(f->type == FD_PIPE)
5372     return piperead(f->pipe, addr, n);
5373   if(f->type == FD_INODE){
5374     ilock(f->ip);
5375     if((r = readi(f->ip, addr, f->off, n)) > 0)
5376       f->off += r;
5377     iunlock(f->ip);
5378     return r;
5379   }
5380   panic("fileread");
5381 }
5382 
5383 
5384 
5385 
5386 
5387 
5388 
5389 
5390 
5391 
5392 
5393 
5394 
5395 
5396 
5397 
5398 
5399 
5400 
5401 int
5402 filewrite(struct file *f, char *addr, int n)
5403 {
5404   int r;
5405 
5406   if(f->writable == 0)
5407     return -1;
5408   if(f->type == FD_PIPE)
5409     return pipewrite(f->pipe, addr, n);
5410   if(f->type == FD_INODE){
5411     
5412     
5413     
5414     
5415     
5416     
5417     int max = ((LOGSIZE-1-1-2) / 2) * 512;
5418     int i = 0;
5419     while(i < n){
5420       int n1 = n - i;
5421       if(n1 > max)
5422         n1 = max;
5423 
5424       begin_trans();
5425       ilock(f->ip);
5426       if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
5427         f->off += r;
5428       iunlock(f->ip);
5429       commit_trans();
5430 
5431       if(r < 0)
5432         break;
5433       if(r != n1)
5434         panic("short filewrite");
5435       i += r;
5436     }
5437     return i == n ? n : -1;
5438   }
5439   panic("filewrite");
5440 }
5441 
5442 
5443 
5444 
5445 
5446 
5447 
5448 
5449 
5450 
5451 
5452 
5453 
5454 
5455 
5456 #include "types.h"
5457 #include "defs.h"
5458 #include "param.h"
5459 #include "stat.h"
5460 #include "mmu.h"
5461 #include "proc.h"
5462 #include "fs.h"
5463 #include "file.h"
5464 #include "fcntl.h"
5465 
5466 
5467 
5468 static int
5469 argfd(int n, int *pfd, struct file **pf)
5470 {
5471   int fd;
5472   struct file *f;
5473 
5474   if(argint(n, &fd) < 0)
5475     return -1;
5476   if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
5477     return -1;
5478   if(pfd)
5479     *pfd = fd;
5480   if(pf)
5481     *pf = f;
5482   return 0;
5483 }
5484 
5485 
5486 
5487 static int
5488 fdalloc(struct file *f)
5489 {
5490   int fd;
5491 
5492   for(fd = 0; fd < NOFILE; fd++){
5493     if(proc->ofile[fd] == 0){
5494       proc->ofile[fd] = f;
5495       return fd;
5496     }
5497   }
5498   return -1;
5499 }
5500 int
5501 sys_dup(void)
5502 {
5503   struct file *f;
5504   int fd;
5505 
5506   if(argfd(0, 0, &f) < 0)
5507     return -1;
5508   if((fd=fdalloc(f)) < 0)
5509     return -1;
5510   filedup(f);
5511   return fd;
5512 }
5513 
5514 int
5515 sys_read(void)
5516 {
5517   struct file *f;
5518   int n;
5519   char *p;
5520 
5521   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
5522     return -1;
5523   return fileread(f, p, n);
5524 }
5525 
5526 int
5527 sys_write(void)
5528 {
5529   struct file *f;
5530   int n;
5531   char *p;
5532 
5533   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
5534     return -1;
5535   return filewrite(f, p, n);
5536 }
5537 
5538 int
5539 sys_close(void)
5540 {
5541   int fd;
5542   struct file *f;
5543 
5544   if(argfd(0, &fd, &f) < 0)
5545     return -1;
5546   proc->ofile[fd] = 0;
5547   fileclose(f);
5548   return 0;
5549 }
5550 int
5551 sys_fstat(void)
5552 {
5553   struct file *f;
5554   struct stat *st;
5555 
5556   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
5557     return -1;
5558   return filestat(f, st);
5559 }
5560 
5561 
5562 int
5563 sys_link(void)
5564 {
5565   char name[DIRSIZ], *new, *old;
5566   struct inode *dp, *ip;
5567 
5568   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
5569     return -1;
5570   if((ip = namei(old)) == 0)
5571     return -1;
5572 
5573   begin_trans();
5574 
5575   ilock(ip);
5576   if(ip->type == T_DIR){
5577     iunlockput(ip);
5578     commit_trans();
5579     return -1;
5580   }
5581 
5582   ip->nlink++;
5583   iupdate(ip);
5584   iunlock(ip);
5585 
5586   if((dp = nameiparent(new, name)) == 0)
5587     goto bad;
5588   ilock(dp);
5589   if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
5590     iunlockput(dp);
5591     goto bad;
5592   }
5593   iunlockput(dp);
5594   iput(ip);
5595 
5596   commit_trans();
5597 
5598   return 0;
5599 
5600 bad:
5601   ilock(ip);
5602   ip->nlink--;
5603   iupdate(ip);
5604   iunlockput(ip);
5605   commit_trans();
5606   return -1;
5607 }
5608 
5609 
5610 static int
5611 isdirempty(struct inode *dp)
5612 {
5613   int off;
5614   struct dirent de;
5615 
5616   for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
5617     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5618       panic("isdirempty: readi");
5619     if(de.inum != 0)
5620       return 0;
5621   }
5622   return 1;
5623 }
5624 
5625 
5626 
5627 
5628 
5629 
5630 
5631 
5632 
5633 
5634 
5635 
5636 
5637 
5638 
5639 
5640 
5641 
5642 
5643 
5644 
5645 
5646 
5647 
5648 
5649 
5650 int
5651 sys_unlink(void)
5652 {
5653   struct inode *ip, *dp;
5654   struct dirent de;
5655   char name[DIRSIZ], *path;
5656   uint off;
5657 
5658   if(argstr(0, &path) < 0)
5659     return -1;
5660   if((dp = nameiparent(path, name)) == 0)
5661     return -1;
5662 
5663   begin_trans();
5664 
5665   ilock(dp);
5666 
5667   
5668   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
5669     goto bad;
5670 
5671   if((ip = dirlookup(dp, name, &off)) == 0)
5672     goto bad;
5673   ilock(ip);
5674 
5675   if(ip->nlink < 1)
5676     panic("unlink: nlink < 1");
5677   if(ip->type == T_DIR && !isdirempty(ip)){
5678     iunlockput(ip);
5679     goto bad;
5680   }
5681 
5682   memset(&de, 0, sizeof(de));
5683   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5684     panic("unlink: writei");
5685   if(ip->type == T_DIR){
5686     dp->nlink--;
5687     iupdate(dp);
5688   }
5689   iunlockput(dp);
5690 
5691   ip->nlink--;
5692   iupdate(ip);
5693   iunlockput(ip);
5694 
5695   commit_trans();
5696 
5697   return 0;
5698 
5699 
5700 bad:
5701   iunlockput(dp);
5702   commit_trans();
5703   return -1;
5704 }
5705 
5706 static struct inode*
5707 create(char *path, short type, short major, short minor)
5708 {
5709   uint off;
5710   struct inode *ip, *dp;
5711   char name[DIRSIZ];
5712 
5713   if((dp = nameiparent(path, name)) == 0)
5714     return 0;
5715   ilock(dp);
5716 
5717   if((ip = dirlookup(dp, name, &off)) != 0){
5718     iunlockput(dp);
5719     ilock(ip);
5720     if(type == T_FILE && ip->type == T_FILE)
5721       return ip;
5722     iunlockput(ip);
5723     return 0;
5724   }
5725 
5726   if((ip = ialloc(dp->dev, type)) == 0)
5727     panic("create: ialloc");
5728 
5729   ilock(ip);
5730   ip->major = major;
5731   ip->minor = minor;
5732   ip->nlink = 1;
5733   iupdate(ip);
5734 
5735   if(type == T_DIR){  
5736     dp->nlink++;  
5737     iupdate(dp);
5738     
5739     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
5740       panic("create dots");
5741   }
5742 
5743   if(dirlink(dp, name, ip->inum) < 0)
5744     panic("create: dirlink");
5745 
5746   iunlockput(dp);
5747 
5748   return ip;
5749 }
5750 int
5751 sys_open(void)
5752 {
5753   char *path;
5754   int fd, omode;
5755   struct file *f;
5756   struct inode *ip;
5757 
5758   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
5759     return -1;
5760   if(omode & O_CREATE){
5761     begin_trans();
5762     ip = create(path, T_FILE, 0, 0);
5763     commit_trans();
5764     if(ip == 0)
5765       return -1;
5766   } else {
5767     if((ip = namei(path)) == 0)
5768       return -1;
5769     ilock(ip);
5770     if(ip->type == T_DIR && omode != O_RDONLY){
5771       iunlockput(ip);
5772       return -1;
5773     }
5774   }
5775 
5776   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
5777     if(f)
5778       fileclose(f);
5779     iunlockput(ip);
5780     return -1;
5781   }
5782   iunlock(ip);
5783 
5784   f->type = FD_INODE;
5785   f->ip = ip;
5786   f->off = 0;
5787   f->readable = !(omode & O_WRONLY);
5788   f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
5789   return fd;
5790 }
5791 
5792 
5793 
5794 
5795 
5796 
5797 
5798 
5799 
5800 int
5801 sys_mkdir(void)
5802 {
5803   char *path;
5804   struct inode *ip;
5805 
5806   begin_trans();
5807   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
5808     commit_trans();
5809     return -1;
5810   }
5811   iunlockput(ip);
5812   commit_trans();
5813   return 0;
5814 }
5815 
5816 int
5817 sys_mknod(void)
5818 {
5819   struct inode *ip;
5820   char *path;
5821   int len;
5822   int major, minor;
5823 
5824   begin_trans();
5825   if((len=argstr(0, &path)) < 0 ||
5826      argint(1, &major) < 0 ||
5827      argint(2, &minor) < 0 ||
5828      (ip = create(path, T_DEV, major, minor)) == 0){
5829     commit_trans();
5830     return -1;
5831   }
5832   iunlockput(ip);
5833   commit_trans();
5834   return 0;
5835 }
5836 
5837 
5838 
5839 
5840 
5841 
5842 
5843 
5844 
5845 
5846 
5847 
5848 
5849 
5850 int
5851 sys_chdir(void)
5852 {
5853   char *path;
5854   struct inode *ip;
5855 
5856   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0)
5857     return -1;
5858   ilock(ip);
5859   if(ip->type != T_DIR){
5860     iunlockput(ip);
5861     return -1;
5862   }
5863   iunlock(ip);
5864   iput(proc->cwd);
5865   proc->cwd = ip;
5866   return 0;
5867 }
5868 
5869 int
5870 sys_exec(void)
5871 {
5872   char *path, *argv[MAXARG];
5873   int i;
5874   uint uargv, uarg;
5875 
5876   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
5877     return -1;
5878   }
5879   memset(argv, 0, sizeof(argv));
5880   for(i=0;; i++){
5881     if(i >= NELEM(argv))
5882       return -1;
5883     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
5884       return -1;
5885     if(uarg == 0){
5886       argv[i] = 0;
5887       break;
5888     }
5889     if(fetchstr(uarg, &argv[i]) < 0)
5890       return -1;
5891   }
5892   return exec(path, argv);
5893 }
5894 
5895 
5896 
5897 
5898 
5899 
5900 int
5901 sys_pipe(void)
5902 {
5903   int *fd;
5904   struct file *rf, *wf;
5905   int fd0, fd1;
5906 
5907   if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
5908     return -1;
5909   if(pipealloc(&rf, &wf) < 0)
5910     return -1;
5911   fd0 = -1;
5912   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
5913     if(fd0 >= 0)
5914       proc->ofile[fd0] = 0;
5915     fileclose(rf);
5916     fileclose(wf);
5917     return -1;
5918   }
5919   fd[0] = fd0;
5920   fd[1] = fd1;
5921   return 0;
5922 }
5923 
5924 
5925 
5926 
5927 
5928 
5929 
5930 
5931 
5932 
5933 
5934 
5935 
5936 
5937 
5938 
5939 
5940 
5941 
5942 
5943 
5944 
5945 
5946 
5947 
5948 
5949 
5950 #include "types.h"
5951 #include "param.h"
5952 #include "memlayout.h"
5953 #include "mmu.h"
5954 #include "proc.h"
5955 #include "defs.h"
5956 #include "x86.h"
5957 #include "elf.h"
5958 
5959 int
5960 exec(char *path, char **argv)
5961 {
5962   char *s, *last;
5963   int i, off;
5964   uint argc, sz, sp, ustack[3+MAXARG+1];
5965   struct elfhdr elf;
5966   struct inode *ip;
5967   struct proghdr ph;
5968   pde_t *pgdir, *oldpgdir;
5969 
5970   if((ip = namei(path)) == 0)
5971     return -1;
5972   ilock(ip);
5973   pgdir = 0;
5974 
5975   
5976   if(readi(ip, (char*)&elf, 0, sizeof(elf)) < sizeof(elf))
5977     goto bad;
5978   if(elf.magic != ELF_MAGIC)
5979     goto bad;
5980 
5981   if((pgdir = setupkvm()) == 0)
5982     goto bad;
5983 
5984   
5985   sz = 0;
5986   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
5987     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
5988       goto bad;
5989     if(ph.type != ELF_PROG_LOAD)
5990       continue;
5991     if(ph.memsz < ph.filesz)
5992       goto bad;
5993     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
5994       goto bad;
5995     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
5996       goto bad;
5997   }
5998   iunlockput(ip);
5999   ip = 0;
6000   
6001   
6002   sz = PGROUNDUP(sz);
6003   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
6004     goto bad;
6005   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
6006   sp = sz;
6007 
6008   
6009   for(argc = 0; argv[argc]; argc++) {
6010     if(argc >= MAXARG)
6011       goto bad;
6012     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
6013     if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
6014       goto bad;
6015     ustack[3+argc] = sp;
6016   }
6017   ustack[3+argc] = 0;
6018 
6019   ustack[0] = 0xffffffff;  
6020   ustack[1] = argc;
6021   ustack[2] = sp - (argc+1)*4;  
6022 
6023   sp -= (3+argc+1) * 4;
6024   if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
6025     goto bad;
6026 
6027   
6028   for(last=s=path; *s; s++)
6029     if(*s == '/')
6030       last = s+1;
6031   safestrcpy(proc->name, last, sizeof(proc->name));
6032 
6033   
6034   oldpgdir = proc->pgdir;
6035   proc->pgdir = pgdir;
6036   proc->sz = sz;
6037   proc->tf->eip = elf.entry;  
6038   proc->tf->esp = sp;
6039   switchuvm(proc);
6040   freevm(oldpgdir);
6041   return 0;
6042 
6043  bad:
6044   if(pgdir)
6045     freevm(pgdir);
6046   if(ip)
6047     iunlockput(ip);
6048   return -1;
6049 }
6050 #include "types.h"
6051 #include "defs.h"
6052 #include "param.h"
6053 #include "mmu.h"
6054 #include "proc.h"
6055 #include "fs.h"
6056 #include "file.h"
6057 #include "spinlock.h"
6058 
6059 #define PIPESIZE 512
6060 
6061 struct pipe {
6062   struct spinlock lock;
6063   char data[PIPESIZE];
6064   uint nread;     
6065   uint nwrite;    
6066   int readopen;   
6067   int writeopen;  
6068 };
6069 
6070 int
6071 pipealloc(struct file **f0, struct file **f1)
6072 {
6073   struct pipe *p;
6074 
6075   p = 0;
6076   *f0 = *f1 = 0;
6077   if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
6078     goto bad;
6079   if((p = (struct pipe*)kalloc()) == 0)
6080     goto bad;
6081   p->readopen = 1;
6082   p->writeopen = 1;
6083   p->nwrite = 0;
6084   p->nread = 0;
6085   initlock(&p->lock, "pipe");
6086   (*f0)->type = FD_PIPE;
6087   (*f0)->readable = 1;
6088   (*f0)->writable = 0;
6089   (*f0)->pipe = p;
6090   (*f1)->type = FD_PIPE;
6091   (*f1)->readable = 0;
6092   (*f1)->writable = 1;
6093   (*f1)->pipe = p;
6094   return 0;
6095 
6096 
6097 
6098 
6099 
6100  bad:
6101   if(p)
6102     kfree((char*)p);
6103   if(*f0)
6104     fileclose(*f0);
6105   if(*f1)
6106     fileclose(*f1);
6107   return -1;
6108 }
6109 
6110 void
6111 pipeclose(struct pipe *p, int writable)
6112 {
6113   acquire(&p->lock);
6114   if(writable){
6115     p->writeopen = 0;
6116     wakeup(&p->nread);
6117   } else {
6118     p->readopen = 0;
6119     wakeup(&p->nwrite);
6120   }
6121   if(p->readopen == 0 && p->writeopen == 0){
6122     release(&p->lock);
6123     kfree((char*)p);
6124   } else
6125     release(&p->lock);
6126 }
6127 
6128 
6129 int
6130 pipewrite(struct pipe *p, char *addr, int n)
6131 {
6132   int i;
6133 
6134   acquire(&p->lock);
6135   for(i = 0; i < n; i++){
6136     while(p->nwrite == p->nread + PIPESIZE){  
6137       if(p->readopen == 0 || proc->killed){
6138         release(&p->lock);
6139         return -1;
6140       }
6141       wakeup(&p->nread);
6142       sleep(&p->nwrite, &p->lock);  
6143     }
6144     p->data[p->nwrite++ % PIPESIZE] = addr[i];
6145   }
6146   wakeup(&p->nread);  
6147   release(&p->lock);
6148   return n;
6149 }
6150 int
6151 piperead(struct pipe *p, char *addr, int n)
6152 {
6153   int i;
6154 
6155   acquire(&p->lock);
6156   while(p->nread == p->nwrite && p->writeopen){  
6157     if(proc->killed){
6158       release(&p->lock);
6159       return -1;
6160     }
6161     sleep(&p->nread, &p->lock); 
6162   }
6163   for(i = 0; i < n; i++){  
6164     if(p->nread == p->nwrite)
6165       break;
6166     addr[i] = p->data[p->nread++ % PIPESIZE];
6167   }
6168   wakeup(&p->nwrite);  
6169   release(&p->lock);
6170   return i;
6171 }
6172 
6173 
6174 
6175 
6176 
6177 
6178 
6179 
6180 
6181 
6182 
6183 
6184 
6185 
6186 
6187 
6188 
6189 
6190 
6191 
6192 
6193 
6194 
6195 
6196 
6197 
6198 
6199 
6200 #include "types.h"
6201 #include "x86.h"
6202 
6203 void*
6204 memset(void *dst, int c, uint n)
6205 {
6206   if ((int)dst%4 == 0 && n%4 == 0){
6207     c &= 0xFF;
6208     stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
6209   } else
6210     stosb(dst, c, n);
6211   return dst;
6212 }
6213 
6214 int
6215 memcmp(const void *v1, const void *v2, uint n)
6216 {
6217   const uchar *s1, *s2;
6218 
6219   s1 = v1;
6220   s2 = v2;
6221   while(n-- > 0){
6222     if(*s1 != *s2)
6223       return *s1 - *s2;
6224     s1++, s2++;
6225   }
6226 
6227   return 0;
6228 }
6229 
6230 void*
6231 memmove(void *dst, const void *src, uint n)
6232 {
6233   const char *s;
6234   char *d;
6235 
6236   s = src;
6237   d = dst;
6238   if(s < d && s + n > d){
6239     s += n;
6240     d += n;
6241     while(n-- > 0)
6242       *--d = *--s;
6243   } else
6244     while(n-- > 0)
6245       *d++ = *s++;
6246 
6247   return dst;
6248 }
6249 
6250 
6251 void*
6252 memcpy(void *dst, const void *src, uint n)
6253 {
6254   return memmove(dst, src, n);
6255 }
6256 
6257 int
6258 strncmp(const char *p, const char *q, uint n)
6259 {
6260   while(n > 0 && *p && *p == *q)
6261     n--, p++, q++;
6262   if(n == 0)
6263     return 0;
6264   return (uchar)*p - (uchar)*q;
6265 }
6266 
6267 char*
6268 strncpy(char *s, const char *t, int n)
6269 {
6270   char *os;
6271 
6272   os = s;
6273   while(n-- > 0 && (*s++ = *t++) != 0)
6274     ;
6275   while(n-- > 0)
6276     *s++ = 0;
6277   return os;
6278 }
6279 
6280 
6281 char*
6282 safestrcpy(char *s, const char *t, int n)
6283 {
6284   char *os;
6285 
6286   os = s;
6287   if(n <= 0)
6288     return os;
6289   while(--n > 0 && (*s++ = *t++) != 0)
6290     ;
6291   *s = 0;
6292   return os;
6293 }
6294 
6295 
6296 
6297 
6298 
6299 
6300 int
6301 strlen(const char *s)
6302 {
6303   int n;
6304 
6305   for(n = 0; s[n]; n++)
6306     ;
6307   return n;
6308 }
6309 
6310 
6311 
6312 
6313 
6314 
6315 
6316 
6317 
6318 
6319 
6320 
6321 
6322 
6323 
6324 
6325 
6326 
6327 
6328 
6329 
6330 
6331 
6332 
6333 
6334 
6335 
6336 
6337 
6338 
6339 
6340 
6341 
6342 
6343 
6344 
6345 
6346 
6347 
6348 
6349 
6350 
6351 
6352 struct mp {             
6353   uchar signature[4];           
6354   void *physaddr;               
6355   uchar length;                 
6356   uchar specrev;                
6357   uchar checksum;               
6358   uchar type;                   
6359   uchar imcrp;
6360   uchar reserved[3];
6361 };
6362 
6363 struct mpconf {         
6364   uchar signature[4];           
6365   ushort length;                
6366   uchar version;                
6367   uchar checksum;               
6368   uchar product[20];            
6369   uint *oemtable;               
6370   ushort oemlength;             
6371   ushort entry;                 
6372   uint *lapicaddr;              
6373   ushort xlength;               
6374   uchar xchecksum;              
6375   uchar reserved;
6376 };
6377 
6378 struct mpproc {         
6379   uchar type;                   
6380   uchar apicid;                 
6381   uchar version;                
6382   uchar flags;                  
6383     #define MPBOOT 0x02           
6384   uchar signature[4];           
6385   uint feature;                 
6386   uchar reserved[8];
6387 };
6388 
6389 struct mpioapic {       
6390   uchar type;                   
6391   uchar apicno;                 
6392   uchar version;                
6393   uchar flags;                  
6394   uint *addr;                  
6395 };
6396 
6397 
6398 
6399 
6400 
6401 #define MPPROC    0x00  
6402 #define MPBUS     0x01  
6403 #define MPIOAPIC  0x02  
6404 #define MPIOINTR  0x03  
6405 #define MPLINTR   0x04  
6406 
6407 
6408 
6409 
6410 
6411 
6412 
6413 
6414 
6415 
6416 
6417 
6418 
6419 
6420 
6421 
6422 
6423 
6424 
6425 
6426 
6427 
6428 
6429 
6430 
6431 
6432 
6433 
6434 
6435 
6436 
6437 
6438 
6439 
6440 
6441 
6442 
6443 
6444 
6445 
6446 
6447 
6448 
6449 
6450 
6451 
6452 
6453 
6454 #include "types.h"
6455 #include "defs.h"
6456 #include "param.h"
6457 #include "memlayout.h"
6458 #include "mp.h"
6459 #include "x86.h"
6460 #include "mmu.h"
6461 #include "proc.h"
6462 
6463 struct cpu cpus[NCPU];
6464 static struct cpu *bcpu;
6465 int ismp;
6466 int ncpu;
6467 uchar ioapicid;
6468 
6469 int
6470 mpbcpu(void)
6471 {
6472   return bcpu-cpus;
6473 }
6474 
6475 static uchar
6476 sum(uchar *addr, int len)
6477 {
6478   int i, sum;
6479 
6480   sum = 0;
6481   for(i=0; i<len; i++)
6482     sum += addr[i];
6483   return sum;
6484 }
6485 
6486 
6487 static struct mp*
6488 mpsearch1(uint a, int len)
6489 {
6490   uchar *e, *p, *addr;
6491 
6492   addr = p2v(a);
6493   e = addr+len;
6494   for(p = addr; p < e; p += sizeof(struct mp))
6495     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
6496       return (struct mp*)p;
6497   return 0;
6498 }
6499 
6500 
6501 
6502 
6503 
6504 
6505 static struct mp*
6506 mpsearch(void)
6507 {
6508   uchar *bda;
6509   uint p;
6510   struct mp *mp;
6511 
6512   bda = (uchar *) P2V(0x400);
6513   if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
6514     if((mp = mpsearch1(p, 1024)))
6515       return mp;
6516   } else {
6517     p = ((bda[0x14]<<8)|bda[0x13])*1024;
6518     if((mp = mpsearch1(p-1024, 1024)))
6519       return mp;
6520   }
6521   return mpsearch1(0xF0000, 0x10000);
6522 }
6523 
6524 
6525 
6526 
6527 
6528 
6529 static struct mpconf*
6530 mpconfig(struct mp **pmp)
6531 {
6532   struct mpconf *conf;
6533   struct mp *mp;
6534 
6535   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
6536     return 0;
6537   conf = (struct mpconf*) p2v((uint) mp->physaddr);
6538   if(memcmp(conf, "PCMP", 4) != 0)
6539     return 0;
6540   if(conf->version != 1 && conf->version != 4)
6541     return 0;
6542   if(sum((uchar*)conf, conf->length) != 0)
6543     return 0;
6544   *pmp = mp;
6545   return conf;
6546 }
6547 
6548 
6549 
6550 void
6551 mpinit(void)
6552 {
6553   uchar *p, *e;
6554   struct mp *mp;
6555   struct mpconf *conf;
6556   struct mpproc *proc;
6557   struct mpioapic *ioapic;
6558 
6559   bcpu = &cpus[0];
6560   if((conf = mpconfig(&mp)) == 0)
6561     return;
6562   ismp = 1;
6563   lapic = (uint*)conf->lapicaddr;
6564   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
6565     switch(*p){
6566     case MPPROC:
6567       proc = (struct mpproc*)p;
6568       if(ncpu != proc->apicid){
6569         cprintf("mpinit: ncpu=%d apicid=%d\n", ncpu, proc->apicid);
6570         ismp = 0;
6571       }
6572       if(proc->flags & MPBOOT)
6573         bcpu = &cpus[ncpu];
6574       cpus[ncpu].id = ncpu;
6575       ncpu++;
6576       p += sizeof(struct mpproc);
6577       continue;
6578     case MPIOAPIC:
6579       ioapic = (struct mpioapic*)p;
6580       ioapicid = ioapic->apicno;
6581       p += sizeof(struct mpioapic);
6582       continue;
6583     case MPBUS:
6584     case MPIOINTR:
6585     case MPLINTR:
6586       p += 8;
6587       continue;
6588     default:
6589       cprintf("mpinit: unknown config type %x\n", *p);
6590       ismp = 0;
6591     }
6592   }
6593   if(!ismp){
6594     
6595     ncpu = 1;
6596     lapic = 0;
6597     ioapicid = 0;
6598     return;
6599   }
6600   if(mp->imcrp){
6601     
6602     
6603     outb(0x22, 0x70);   
6604     outb(0x23, inb(0x23) | 1);  
6605   }
6606 }
6607 
6608 
6609 
6610 
6611 
6612 
6613 
6614 
6615 
6616 
6617 
6618 
6619 
6620 
6621 
6622 
6623 
6624 
6625 
6626 
6627 
6628 
6629 
6630 
6631 
6632 
6633 
6634 
6635 
6636 
6637 
6638 
6639 
6640 
6641 
6642 
6643 
6644 
6645 
6646 
6647 
6648 
6649 
6650 
6651 
6652 
6653 #include "types.h"
6654 #include "defs.h"
6655 #include "memlayout.h"
6656 #include "traps.h"
6657 #include "mmu.h"
6658 #include "x86.h"
6659 
6660 
6661 #define ID      (0x0020/4)   
6662 #define VER     (0x0030/4)   
6663 #define TPR     (0x0080/4)   
6664 #define EOI     (0x00B0/4)   
6665 #define SVR     (0x00F0/4)   
6666   #define ENABLE     0x00000100   
6667 #define ESR     (0x0280/4)   
6668 #define ICRLO   (0x0300/4)   
6669   #define INIT       0x00000500   
6670   #define STARTUP    0x00000600   
6671   #define DELIVS     0x00001000   
6672   #define ASSERT     0x00004000   
6673   #define DEASSERT   0x00000000
6674   #define LEVEL      0x00008000   
6675   #define BCAST      0x00080000   
6676   #define BUSY       0x00001000
6677   #define FIXED      0x00000000
6678 #define ICRHI   (0x0310/4)   
6679 #define TIMER   (0x0320/4)   
6680   #define X1         0x0000000B   
6681   #define PERIODIC   0x00020000   
6682 #define PCINT   (0x0340/4)   
6683 #define LINT0   (0x0350/4)   
6684 #define LINT1   (0x0360/4)   
6685 #define ERROR   (0x0370/4)   
6686   #define MASKED     0x00010000   
6687 #define TICR    (0x0380/4)   
6688 #define TCCR    (0x0390/4)   
6689 #define TDCR    (0x03E0/4)   
6690 
6691 volatile uint *lapic;  
6692 
6693 static void
6694 lapicw(int index, int value)
6695 {
6696   lapic[index] = value;
6697   lapic[ID];  
6698 }
6699 
6700 void
6701 lapicinit(void)
6702 {
6703   if(!lapic)
6704     return;
6705 
6706   
6707   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
6708 
6709   
6710   
6711   
6712   
6713   lapicw(TDCR, X1);
6714   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
6715   lapicw(TICR, 10000000);
6716 
6717   
6718   lapicw(LINT0, MASKED);
6719   lapicw(LINT1, MASKED);
6720 
6721   
6722   
6723   if(((lapic[VER]>>16) & 0xFF) >= 4)
6724     lapicw(PCINT, MASKED);
6725 
6726   
6727   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
6728 
6729   
6730   lapicw(ESR, 0);
6731   lapicw(ESR, 0);
6732 
6733   
6734   lapicw(EOI, 0);
6735 
6736   
6737   lapicw(ICRHI, 0);
6738   lapicw(ICRLO, BCAST | INIT | LEVEL);
6739   while(lapic[ICRLO] & DELIVS)
6740     ;
6741 
6742   
6743   lapicw(TPR, 0);
6744 }
6745 
6746 
6747 
6748 
6749 
6750 int
6751 cpunum(void)
6752 {
6753   
6754   
6755   
6756   
6757   
6758   if(readeflags()&FL_IF){
6759     static int n;
6760     if(n++ == 0)
6761       cprintf("cpu called from %x with interrupts enabled\n",
6762         __builtin_return_address(0));
6763   }
6764 
6765   if(lapic)
6766     return lapic[ID]>>24;
6767   return 0;
6768 }
6769 
6770 
6771 void
6772 lapiceoi(void)
6773 {
6774   if(lapic)
6775     lapicw(EOI, 0);
6776 }
6777 
6778 
6779 
6780 void
6781 microdelay(int us)
6782 {
6783 }
6784 
6785 #define IO_RTC  0x70
6786 
6787 
6788 
6789 void
6790 lapicstartap(uchar apicid, uint addr)
6791 {
6792   int i;
6793   ushort *wrv;
6794 
6795   
6796   
6797   
6798   outb(IO_RTC, 0xF);  
6799   outb(IO_RTC+1, 0x0A);
6800   wrv = (ushort*)P2V((0x40<<4 | 0x67));  
6801   wrv[0] = 0;
6802   wrv[1] = addr >> 4;
6803 
6804   
6805   
6806   lapicw(ICRHI, apicid<<24);
6807   lapicw(ICRLO, INIT | LEVEL | ASSERT);
6808   microdelay(200);
6809   lapicw(ICRLO, INIT | LEVEL);
6810   microdelay(100);    
6811 
6812   
6813   
6814   
6815   
6816   
6817   for(i = 0; i < 2; i++){
6818     lapicw(ICRHI, apicid<<24);
6819     lapicw(ICRLO, STARTUP | (addr>>12));
6820     microdelay(200);
6821   }
6822 }
6823 
6824 
6825 
6826 
6827 
6828 
6829 
6830 
6831 
6832 
6833 
6834 
6835 
6836 
6837 
6838 
6839 
6840 
6841 
6842 
6843 
6844 
6845 
6846 
6847 
6848 
6849 
6850 
6851 
6852 
6853 
6854 #include "types.h"
6855 #include "defs.h"
6856 #include "traps.h"
6857 
6858 #define IOAPIC  0xFEC00000   
6859 
6860 #define REG_ID     0x00  
6861 #define REG_VER    0x01  
6862 #define REG_TABLE  0x10  
6863 
6864 
6865 
6866 
6867 
6868 
6869 #define INT_DISABLED   0x00010000  
6870 #define INT_LEVEL      0x00008000  
6871 #define INT_ACTIVELOW  0x00002000  
6872 #define INT_LOGICAL    0x00000800  
6873 
6874 volatile struct ioapic *ioapic;
6875 
6876 
6877 struct ioapic {
6878   uint reg;
6879   uint pad[3];
6880   uint data;
6881 };
6882 
6883 static uint
6884 ioapicread(int reg)
6885 {
6886   ioapic->reg = reg;
6887   return ioapic->data;
6888 }
6889 
6890 static void
6891 ioapicwrite(int reg, uint data)
6892 {
6893   ioapic->reg = reg;
6894   ioapic->data = data;
6895 }
6896 
6897 
6898 
6899 
6900 void
6901 ioapicinit(void)
6902 {
6903   int i, id, maxintr;
6904 
6905   if(!ismp)
6906     return;
6907 
6908   ioapic = (volatile struct ioapic*)IOAPIC;
6909   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
6910   id = ioapicread(REG_ID) >> 24;
6911   if(id != ioapicid)
6912     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
6913 
6914   
6915   
6916   for(i = 0; i <= maxintr; i++){
6917     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
6918     ioapicwrite(REG_TABLE+2*i+1, 0);
6919   }
6920 }
6921 
6922 void
6923 ioapicenable(int irq, int cpunum)
6924 {
6925   if(!ismp)
6926     return;
6927 
6928   
6929   
6930   
6931   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
6932   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
6933 }
6934 
6935 
6936 
6937 
6938 
6939 
6940 
6941 
6942 
6943 
6944 
6945 
6946 
6947 
6948 
6949 
6950 
6951 
6952 #include "types.h"
6953 #include "x86.h"
6954 #include "traps.h"
6955 
6956 
6957 #define IO_PIC1         0x20    
6958 #define IO_PIC2         0xA0    
6959 
6960 #define IRQ_SLAVE       2       
6961 
6962 
6963 
6964 static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);
6965 
6966 static void
6967 picsetmask(ushort mask)
6968 {
6969   irqmask = mask;
6970   outb(IO_PIC1+1, mask);
6971   outb(IO_PIC2+1, mask >> 8);
6972 }
6973 
6974 void
6975 picenable(int irq)
6976 {
6977   picsetmask(irqmask & ~(1<<irq));
6978 }
6979 
6980 
6981 void
6982 picinit(void)
6983 {
6984   
6985   outb(IO_PIC1+1, 0xFF);
6986   outb(IO_PIC2+1, 0xFF);
6987 
6988   
6989 
6990   
6991   
6992   
6993   
6994   outb(IO_PIC1, 0x11);
6995 
6996   
6997   outb(IO_PIC1+1, T_IRQ0);
6998 
6999 
7000   
7001   
7002   outb(IO_PIC1+1, 1<<IRQ_SLAVE);
7003 
7004   
7005   
7006   
7007   
7008   
7009   
7010   
7011   
7012   outb(IO_PIC1+1, 0x3);
7013 
7014   
7015   outb(IO_PIC2, 0x11);                  
7016   outb(IO_PIC2+1, T_IRQ0 + 8);      
7017   outb(IO_PIC2+1, IRQ_SLAVE);           
7018   
7019   
7020   outb(IO_PIC2+1, 0x3);                 
7021 
7022   
7023   
7024   
7025   
7026   outb(IO_PIC1, 0x68);             
7027   outb(IO_PIC1, 0x0a);             
7028 
7029   outb(IO_PIC2, 0x68);             
7030   outb(IO_PIC2, 0x0a);             
7031 
7032   if(irqmask != 0xFFFF)
7033     picsetmask(irqmask);
7034 }
7035 
7036 
7037 
7038 
7039 
7040 
7041 
7042 
7043 
7044 
7045 
7046 
7047 
7048 
7049 
7050 
7051 
7052 #define KBSTATP         0x64    
7053 #define KBS_DIB         0x01    
7054 #define KBDATAP         0x60    
7055 
7056 #define NO              0
7057 
7058 #define SHIFT           (1<<0)
7059 #define CTL             (1<<1)
7060 #define ALT             (1<<2)
7061 
7062 #define CAPSLOCK        (1<<3)
7063 #define NUMLOCK         (1<<4)
7064 #define SCROLLLOCK      (1<<5)
7065 
7066 #define E0ESC           (1<<6)
7067 
7068 
7069 #define KEY_HOME        0xE0
7070 #define KEY_END         0xE1
7071 #define KEY_UP          0xE2
7072 #define KEY_DN          0xE3
7073 #define KEY_LF          0xE4
7074 #define KEY_RT          0xE5
7075 #define KEY_PGUP        0xE6
7076 #define KEY_PGDN        0xE7
7077 #define KEY_INS         0xE8
7078 #define KEY_DEL         0xE9
7079 
7080 
7081 #define C(x) (x - '@')
7082 
7083 static uchar shiftcode[256] =
7084 {
7085   [0x1D] CTL,
7086   [0x2A] SHIFT,
7087   [0x36] SHIFT,
7088   [0x38] ALT,
7089   [0x9D] CTL,
7090   [0xB8] ALT
7091 };
7092 
7093 static uchar togglecode[256] =
7094 {
7095   [0x3A] CAPSLOCK,
7096   [0x45] NUMLOCK,
7097   [0x46] SCROLLLOCK
7098 };
7099 
7100 static uchar normalmap[256] =
7101 {
7102   NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  
7103   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
7104   'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  
7105   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
7106   'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  
7107   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
7108   'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  
7109   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7110   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7111   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7112   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7113   [0x9C] '\n',      
7114   [0xB5] '/',       
7115   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7116   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7117   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7118   [0x97] KEY_HOME,  [0xCF] KEY_END,
7119   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7120 };
7121 
7122 static uchar shiftmap[256] =
7123 {
7124   NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  
7125   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
7126   'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  
7127   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
7128   'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  
7129   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
7130   'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  
7131   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7132   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7133   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7134   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7135   [0x9C] '\n',      
7136   [0xB5] '/',       
7137   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7138   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7139   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7140   [0x97] KEY_HOME,  [0xCF] KEY_END,
7141   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7142 };
7143 
7144 
7145 
7146 
7147 
7148 
7149 
7150 static uchar ctlmap[256] =
7151 {
7152   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7153   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7154   C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
7155   C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
7156   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
7157   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
7158   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
7159   [0x9C] '\r',      
7160   [0xB5] C('/'),    
7161   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7162   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7163   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7164   [0x97] KEY_HOME,  [0xCF] KEY_END,
7165   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7166 };
7167 
7168 
7169 
7170 
7171 
7172 
7173 
7174 
7175 
7176 
7177 
7178 
7179 
7180 
7181 
7182 
7183 
7184 
7185 
7186 
7187 
7188 
7189 
7190 
7191 
7192 
7193 
7194 
7195 
7196 
7197 
7198 
7199 
7200 #include "types.h"
7201 #include "x86.h"
7202 #include "defs.h"
7203 #include "kbd.h"
7204 
7205 int
7206 kbdgetc(void)
7207 {
7208   static uint shift;
7209   static uchar *charcode[4] = {
7210     normalmap, shiftmap, ctlmap, ctlmap
7211   };
7212   uint st, data, c;
7213 
7214   st = inb(KBSTATP);
7215   if((st & KBS_DIB) == 0)
7216     return -1;
7217   data = inb(KBDATAP);
7218 
7219   if(data == 0xE0){
7220     shift |= E0ESC;
7221     return 0;
7222   } else if(data & 0x80){
7223     
7224     data = (shift & E0ESC ? data : data & 0x7F);
7225     shift &= ~(shiftcode[data] | E0ESC);
7226     return 0;
7227   } else if(shift & E0ESC){
7228     
7229     data |= 0x80;
7230     shift &= ~E0ESC;
7231   }
7232 
7233   shift |= shiftcode[data];
7234   shift ^= togglecode[data];
7235   c = charcode[shift & (CTL | SHIFT)][data];
7236   if(shift & CAPSLOCK){
7237     if('a' <= c && c <= 'z')
7238       c += 'A' - 'a';
7239     else if('A' <= c && c <= 'Z')
7240       c += 'a' - 'A';
7241   }
7242   return c;
7243 }
7244 
7245 void
7246 kbdintr(void)
7247 {
7248   consoleintr(kbdgetc);
7249 }
7250 
7251 
7252 
7253 
7254 #include "types.h"
7255 #include "defs.h"
7256 #include "param.h"
7257 #include "traps.h"
7258 #include "spinlock.h"
7259 #include "fs.h"
7260 #include "file.h"
7261 #include "memlayout.h"
7262 #include "mmu.h"
7263 #include "proc.h"
7264 #include "x86.h"
7265 
7266 static void consputc(int);
7267 
7268 static int panicked = 0;
7269 
7270 static struct {
7271   struct spinlock lock;
7272   int locking;
7273 } cons;
7274 
7275 static void
7276 printint(int xx, int base, int sign)
7277 {
7278   static char digits[] = "0123456789abcdef";
7279   char buf[16];
7280   int i;
7281   uint x;
7282 
7283   if(sign && (sign = xx < 0))
7284     x = -xx;
7285   else
7286     x = xx;
7287 
7288   i = 0;
7289   do{
7290     buf[i++] = digits[x % base];
7291   }while((x /= base) != 0);
7292 
7293   if(sign)
7294     buf[i++] = '-';
7295 
7296   while(--i >= 0)
7297     consputc(buf[i]);
7298 }
7299 
7300 
7301 void
7302 cprintf(char *fmt, ...)
7303 {
7304   int i, c, locking;
7305   uint *argp;
7306   char *s;
7307 
7308   locking = cons.locking;
7309   if(locking)
7310     acquire(&cons.lock);
7311 
7312   if (fmt == 0)
7313     panic("null fmt");
7314 
7315   argp = (uint*)(void*)(&fmt + 1);
7316   for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
7317     if(c != '%'){
7318       consputc(c);
7319       continue;
7320     }
7321     c = fmt[++i] & 0xff;
7322     if(c == 0)
7323       break;
7324     switch(c){
7325     case 'd':
7326       printint(*argp++, 10, 1);
7327       break;
7328     case 'x':
7329     case 'p':
7330       printint(*argp++, 16, 0);
7331       break;
7332     case 's':
7333       if((s = (char*)*argp++) == 0)
7334         s = "(null)";
7335       for(; *s; s++)
7336         consputc(*s);
7337       break;
7338     case '%':
7339       consputc('%');
7340       break;
7341     default:
7342       
7343       consputc('%');
7344       consputc(c);
7345       break;
7346     }
7347   }
7348 
7349 
7350   if(locking)
7351     release(&cons.lock);
7352 }
7353 
7354 void
7355 panic(char *s)
7356 {
7357   int i;
7358   uint pcs[10];
7359 
7360   cli();
7361   cons.locking = 0;
7362   cprintf("cpu%d: panic: ", cpu->id);
7363   cprintf(s);
7364   cprintf("\n");
7365   getcallerpcs(&s, pcs);
7366   for(i=0; i<10; i++)
7367     cprintf(" %p", pcs[i]);
7368   panicked = 1; 
7369   for(;;)
7370     ;
7371 }
7372 
7373 
7374 
7375 
7376 
7377 
7378 
7379 
7380 
7381 
7382 
7383 
7384 
7385 
7386 
7387 
7388 
7389 
7390 
7391 
7392 
7393 
7394 
7395 
7396 
7397 
7398 
7399 
7400 #define BACKSPACE 0x100
7401 #define CRTPORT 0x3d4
7402 static ushort *crt = (ushort*)P2V(0xb8000);  
7403 
7404 static void
7405 cgaputc(int c)
7406 {
7407   int pos;
7408 
7409   
7410   outb(CRTPORT, 14);
7411   pos = inb(CRTPORT+1) << 8;
7412   outb(CRTPORT, 15);
7413   pos |= inb(CRTPORT+1);
7414 
7415   if(c == '\n')
7416     pos += 80 - pos%80;
7417   else if(c == BACKSPACE){
7418     if(pos > 0) --pos;
7419   } else
7420     crt[pos++] = (c&0xff) | 0x0700;  
7421 
7422   if((pos/80) >= 24){  
7423     memmove(crt, crt+80, sizeof(crt[0])*23*80);
7424     pos -= 80;
7425     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
7426   }
7427 
7428   outb(CRTPORT, 14);
7429   outb(CRTPORT+1, pos>>8);
7430   outb(CRTPORT, 15);
7431   outb(CRTPORT+1, pos);
7432   crt[pos] = ' ' | 0x0700;
7433 }
7434 
7435 void
7436 consputc(int c)
7437 {
7438   if(panicked){
7439     cli();
7440     for(;;)
7441       ;
7442   }
7443 
7444   if(c == BACKSPACE){
7445     uartputc('\b'); uartputc(' '); uartputc('\b');
7446   } else
7447     uartputc(c);
7448   cgaputc(c);
7449 }
7450 #define INPUT_BUF 128
7451 struct {
7452   struct spinlock lock;
7453   char buf[INPUT_BUF];
7454   uint r;  
7455   uint w;  
7456   uint e;  
7457 } input;
7458 
7459 #define C(x)  ((x)-'@')  
7460 
7461 void
7462 consoleintr(int (*getc)(void))
7463 {
7464   int c;
7465 
7466   acquire(&input.lock);
7467   while((c = getc()) >= 0){
7468     switch(c){
7469     case C('P'):  
7470       procdump();
7471       break;
7472     case C('U'):  
7473       while(input.e != input.w &&
7474             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
7475         input.e--;
7476         consputc(BACKSPACE);
7477       }
7478       break;
7479     case C('H'): case '\x7f':  
7480       if(input.e != input.w){
7481         input.e--;
7482         consputc(BACKSPACE);
7483       }
7484       break;
7485     default:
7486       if(c != 0 && input.e-input.r < INPUT_BUF){
7487         c = (c == '\r') ? '\n' : c;
7488         input.buf[input.e++ % INPUT_BUF] = c;
7489         consputc(c);
7490         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
7491           input.w = input.e;
7492           wakeup(&input.r);
7493         }
7494       }
7495       break;
7496     }
7497   }
7498   release(&input.lock);
7499 }
7500 int
7501 consoleread(struct inode *ip, char *dst, int n)
7502 {
7503   uint target;
7504   int c;
7505 
7506   iunlock(ip);
7507   target = n;
7508   acquire(&input.lock);
7509   while(n > 0){
7510     while(input.r == input.w){
7511       if(proc->killed){
7512         release(&input.lock);
7513         ilock(ip);
7514         return -1;
7515       }
7516       sleep(&input.r, &input.lock);
7517     }
7518     c = input.buf[input.r++ % INPUT_BUF];
7519     if(c == C('D')){  
7520       if(n < target){
7521         
7522         
7523         input.r--;
7524       }
7525       break;
7526     }
7527     *dst++ = c;
7528     --n;
7529     if(c == '\n')
7530       break;
7531   }
7532   release(&input.lock);
7533   ilock(ip);
7534 
7535   return target - n;
7536 }
7537 
7538 
7539 
7540 
7541 
7542 
7543 
7544 
7545 
7546 
7547 
7548 
7549 
7550 int
7551 consolewrite(struct inode *ip, char *buf, int n)
7552 {
7553   int i;
7554 
7555   iunlock(ip);
7556   acquire(&cons.lock);
7557   for(i = 0; i < n; i++)
7558     consputc(buf[i] & 0xff);
7559   release(&cons.lock);
7560   ilock(ip);
7561 
7562   return n;
7563 }
7564 
7565 void
7566 consoleinit(void)
7567 {
7568   initlock(&cons.lock, "console");
7569   initlock(&input.lock, "input");
7570 
7571   devsw[CONSOLE].write = consolewrite;
7572   devsw[CONSOLE].read = consoleread;
7573   cons.locking = 1;
7574 
7575   picenable(IRQ_KBD);
7576   ioapicenable(IRQ_KBD, 0);
7577 }
7578 
7579 
7580 
7581 
7582 
7583 
7584 
7585 
7586 
7587 
7588 
7589 
7590 
7591 
7592 
7593 
7594 
7595 
7596 
7597 
7598 
7599 
7600 
7601 
7602 
7603 
7604 #include "types.h"
7605 #include "defs.h"
7606 #include "traps.h"
7607 #include "x86.h"
7608 
7609 #define IO_TIMER1       0x040           
7610 
7611 
7612 
7613 
7614 
7615 #define TIMER_FREQ      1193182
7616 #define TIMER_DIV(x)    ((TIMER_FREQ+(x)/2)/(x))
7617 
7618 #define TIMER_MODE      (IO_TIMER1 + 3) 
7619 #define TIMER_SEL0      0x00    
7620 #define TIMER_RATEGEN   0x04    
7621 #define TIMER_16BIT     0x30    
7622 
7623 void
7624 timerinit(void)
7625 {
7626   
7627   outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
7628   outb(IO_TIMER1, TIMER_DIV(100) % 256);
7629   outb(IO_TIMER1, TIMER_DIV(100) / 256);
7630   picenable(IRQ_TIMER);
7631 }
7632 
7633 
7634 
7635 
7636 
7637 
7638 
7639 
7640 
7641 
7642 
7643 
7644 
7645 
7646 
7647 
7648 
7649 
7650 
7651 
7652 #include "types.h"
7653 #include "defs.h"
7654 #include "param.h"
7655 #include "traps.h"
7656 #include "spinlock.h"
7657 #include "fs.h"
7658 #include "file.h"
7659 #include "mmu.h"
7660 #include "proc.h"
7661 #include "x86.h"
7662 
7663 #define COM1    0x3f8
7664 
7665 static int uart;    
7666 
7667 void
7668 uartinit(void)
7669 {
7670   char *p;
7671 
7672   
7673   outb(COM1+2, 0);
7674 
7675   
7676   outb(COM1+3, 0x80);    
7677   outb(COM1+0, 115200/9600);
7678   outb(COM1+1, 0);
7679   outb(COM1+3, 0x03);    
7680   outb(COM1+4, 0);
7681   outb(COM1+1, 0x01);    
7682 
7683   
7684   if(inb(COM1+5) == 0xFF)
7685     return;
7686   uart = 1;
7687 
7688   
7689   
7690   inb(COM1+2);
7691   inb(COM1+0);
7692   picenable(IRQ_COM1);
7693   ioapicenable(IRQ_COM1, 0);
7694 
7695   
7696   for(p="xv6...\n"; *p; p++)
7697     uartputc(*p);
7698 }
7699 
7700 void
7701 uartputc(int c)
7702 {
7703   int i;
7704 
7705   if(!uart)
7706     return;
7707   for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
7708     microdelay(10);
7709   outb(COM1+0, c);
7710 }
7711 
7712 static int
7713 uartgetc(void)
7714 {
7715   if(!uart)
7716     return -1;
7717   if(!(inb(COM1+5) & 0x01))
7718     return -1;
7719   return inb(COM1+0);
7720 }
7721 
7722 void
7723 uartintr(void)
7724 {
7725   consoleintr(uartgetc);
7726 }
7727 
7728 
7729 
7730 
7731 
7732 
7733 
7734 
7735 
7736 
7737 
7738 
7739 
7740 
7741 
7742 
7743 
7744 
7745 
7746 
7747 
7748 
7749 
7750 
7751 
7752 
7753 
7754 
7755 
7756 
7757 .globl start
7758 start:
7759   pushl $argv
7760   pushl $init
7761   pushl $0  
7762   movl $SYS_exec, %eax
7763   int $T_SYSCALL
7764 
7765 
7766 exit:
7767   movl $SYS_exit, %eax
7768   int $T_SYSCALL
7769   jmp exit
7770 
7771 
7772 init:
7773   .string "/init\0"
7774 
7775 
7776 .p2align 2
7777 argv:
7778   .long init
7779   .long 0
7780 
7781 
7782 
7783 
7784 
7785 
7786 
7787 
7788 
7789 
7790 
7791 
7792 
7793 
7794 
7795 
7796 
7797 
7798 
7799 
7800 
7801 
7802 
7803 
7804   .globl name; \
7805   name: \
7806     movl $SYS_ 
7807     int $T_SYSCALL; \
7808     ret
7809 
7810 SYSCALL(fork)
7811 SYSCALL(exit)
7812 SYSCALL(wait)
7813 SYSCALL(pipe)
7814 SYSCALL(read)
7815 SYSCALL(write)
7816 SYSCALL(close)
7817 SYSCALL(kill)
7818 SYSCALL(exec)
7819 SYSCALL(open)
7820 SYSCALL(mknod)
7821 SYSCALL(unlink)
7822 SYSCALL(fstat)
7823 SYSCALL(link)
7824 SYSCALL(mkdir)
7825 SYSCALL(chdir)
7826 SYSCALL(dup)
7827 SYSCALL(getpid)
7828 SYSCALL(sbrk)
7829 SYSCALL(sleep)
7830 SYSCALL(uptime)
7831 
7832 
7833 
7834 
7835 
7836 
7837 
7838 
7839 
7840 
7841 
7842 
7843 
7844 
7845 
7846 
7847 
7848 
7849 
7850 
7851 
7852 #include "types.h"
7853 #include "stat.h"
7854 #include "user.h"
7855 #include "fcntl.h"
7856 
7857 char *argv[] = { "sh", 0 };
7858 
7859 int
7860 main(void)
7861 {
7862   int pid, wpid;
7863 
7864   if(open("console", O_RDWR) < 0){
7865     mknod("console", 1, 1);
7866     open("console", O_RDWR);
7867   }
7868   dup(0);  
7869   dup(0);  
7870 
7871   for(;;){
7872     printf(1, "init: starting sh\n");
7873     pid = fork();
7874     if(pid < 0){
7875       printf(1, "init: fork failed\n");
7876       exit();
7877     }
7878     if(pid == 0){
7879       exec("sh", argv);
7880       printf(1, "init: exec sh failed\n");
7881       exit();
7882     }
7883     while((wpid=wait()) >= 0 && wpid != pid)
7884       printf(1, "zombie!\n");
7885   }
7886 }
7887 
7888 
7889 
7890 
7891 
7892 
7893 
7894 
7895 
7896 
7897 
7898 
7899 
7900 
7901 
7902 #include "types.h"
7903 #include "user.h"
7904 #include "fcntl.h"
7905 
7906 
7907 #define EXEC  1
7908 #define REDIR 2
7909 #define PIPE  3
7910 #define LIST  4
7911 #define BACK  5
7912 
7913 #define MAXARGS 10
7914 
7915 struct cmd {
7916   int type;
7917 };
7918 
7919 struct execcmd {
7920   int type;
7921   char *argv[MAXARGS];
7922   char *eargv[MAXARGS];
7923 };
7924 
7925 struct redircmd {
7926   int type;
7927   struct cmd *cmd;
7928   char *file;
7929   char *efile;
7930   int mode;
7931   int fd;
7932 };
7933 
7934 struct pipecmd {
7935   int type;
7936   struct cmd *left;
7937   struct cmd *right;
7938 };
7939 
7940 struct listcmd {
7941   int type;
7942   struct cmd *left;
7943   struct cmd *right;
7944 };
7945 
7946 struct backcmd {
7947   int type;
7948   struct cmd *cmd;
7949 };
7950 int fork1(void);  
7951 void panic(char*);
7952 struct cmd *parsecmd(char*);
7953 
7954 
7955 void
7956 runcmd(struct cmd *cmd)
7957 {
7958   int p[2];
7959   struct backcmd *bcmd;
7960   struct execcmd *ecmd;
7961   struct listcmd *lcmd;
7962   struct pipecmd *pcmd;
7963   struct redircmd *rcmd;
7964 
7965   if(cmd == 0)
7966     exit();
7967 
7968   switch(cmd->type){
7969   default:
7970     panic("runcmd");
7971 
7972   case EXEC:
7973     ecmd = (struct execcmd*)cmd;
7974     if(ecmd->argv[0] == 0)
7975       exit();
7976     exec(ecmd->argv[0], ecmd->argv);
7977     printf(2, "exec %s failed\n", ecmd->argv[0]);
7978     break;
7979 
7980   case REDIR:
7981     rcmd = (struct redircmd*)cmd;
7982     close(rcmd->fd);
7983     if(open(rcmd->file, rcmd->mode) < 0){
7984       printf(2, "open %s failed\n", rcmd->file);
7985       exit();
7986     }
7987     runcmd(rcmd->cmd);
7988     break;
7989 
7990   case LIST:
7991     lcmd = (struct listcmd*)cmd;
7992     if(fork1() == 0)
7993       runcmd(lcmd->left);
7994     wait();
7995     runcmd(lcmd->right);
7996     break;
7997 
7998 
7999 
8000   case PIPE:
8001     pcmd = (struct pipecmd*)cmd;
8002     if(pipe(p) < 0)
8003       panic("pipe");
8004     if(fork1() == 0){
8005       close(1);
8006       dup(p[1]);
8007       close(p[0]);
8008       close(p[1]);
8009       runcmd(pcmd->left);
8010     }
8011     if(fork1() == 0){
8012       close(0);
8013       dup(p[0]);
8014       close(p[0]);
8015       close(p[1]);
8016       runcmd(pcmd->right);
8017     }
8018     close(p[0]);
8019     close(p[1]);
8020     wait();
8021     wait();
8022     break;
8023 
8024   case BACK:
8025     bcmd = (struct backcmd*)cmd;
8026     if(fork1() == 0)
8027       runcmd(bcmd->cmd);
8028     break;
8029   }
8030   exit();
8031 }
8032 
8033 int
8034 getcmd(char *buf, int nbuf)
8035 {
8036   printf(2, "$ ");
8037   memset(buf, 0, nbuf);
8038   gets(buf, nbuf);
8039   if(buf[0] == 0) 
8040     return -1;
8041   return 0;
8042 }
8043 
8044 
8045 
8046 
8047 
8048 
8049 
8050 int
8051 main(void)
8052 {
8053   static char buf[100];
8054   int fd;
8055 
8056   
8057   while((fd = open("console", O_RDWR)) >= 0){
8058     if(fd >= 3){
8059       close(fd);
8060       break;
8061     }
8062   }
8063 
8064   
8065   while(getcmd(buf, sizeof(buf)) >= 0){
8066     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
8067       
8068       
8069       buf[strlen(buf)-1] = 0;  
8070       if(chdir(buf+3) < 0)
8071         printf(2, "cannot cd %s\n", buf+3);
8072       continue;
8073     }
8074     if(fork1() == 0)
8075       runcmd(parsecmd(buf));
8076     wait();
8077   }
8078   exit();
8079 }
8080 
8081 void
8082 panic(char *s)
8083 {
8084   printf(2, "%s\n", s);
8085   exit();
8086 }
8087 
8088 int
8089 fork1(void)
8090 {
8091   int pid;
8092 
8093   pid = fork();
8094   if(pid == -1)
8095     panic("fork");
8096   return pid;
8097 }
8098 
8099 
8100 
8101 
8102 struct cmd*
8103 execcmd(void)
8104 {
8105   struct execcmd *cmd;
8106 
8107   cmd = malloc(sizeof(*cmd));
8108   memset(cmd, 0, sizeof(*cmd));
8109   cmd->type = EXEC;
8110   return (struct cmd*)cmd;
8111 }
8112 
8113 struct cmd*
8114 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
8115 {
8116   struct redircmd *cmd;
8117 
8118   cmd = malloc(sizeof(*cmd));
8119   memset(cmd, 0, sizeof(*cmd));
8120   cmd->type = REDIR;
8121   cmd->cmd = subcmd;
8122   cmd->file = file;
8123   cmd->efile = efile;
8124   cmd->mode = mode;
8125   cmd->fd = fd;
8126   return (struct cmd*)cmd;
8127 }
8128 
8129 struct cmd*
8130 pipecmd(struct cmd *left, struct cmd *right)
8131 {
8132   struct pipecmd *cmd;
8133 
8134   cmd = malloc(sizeof(*cmd));
8135   memset(cmd, 0, sizeof(*cmd));
8136   cmd->type = PIPE;
8137   cmd->left = left;
8138   cmd->right = right;
8139   return (struct cmd*)cmd;
8140 }
8141 
8142 
8143 
8144 
8145 
8146 
8147 
8148 
8149 
8150 struct cmd*
8151 listcmd(struct cmd *left, struct cmd *right)
8152 {
8153   struct listcmd *cmd;
8154 
8155   cmd = malloc(sizeof(*cmd));
8156   memset(cmd, 0, sizeof(*cmd));
8157   cmd->type = LIST;
8158   cmd->left = left;
8159   cmd->right = right;
8160   return (struct cmd*)cmd;
8161 }
8162 
8163 struct cmd*
8164 backcmd(struct cmd *subcmd)
8165 {
8166   struct backcmd *cmd;
8167 
8168   cmd = malloc(sizeof(*cmd));
8169   memset(cmd, 0, sizeof(*cmd));
8170   cmd->type = BACK;
8171   cmd->cmd = subcmd;
8172   return (struct cmd*)cmd;
8173 }
8174 
8175 
8176 
8177 
8178 
8179 
8180 
8181 
8182 
8183 
8184 
8185 
8186 
8187 
8188 
8189 
8190 
8191 
8192 
8193 
8194 
8195 
8196 
8197 
8198 
8199 
8200 
8201 
8202 char whitespace[] = " \t\r\n\v";
8203 char symbols[] = "<|>&;()";
8204 
8205 int
8206 gettoken(char **ps, char *es, char **q, char **eq)
8207 {
8208   char *s;
8209   int ret;
8210 
8211   s = *ps;
8212   while(s < es && strchr(whitespace, *s))
8213     s++;
8214   if(q)
8215     *q = s;
8216   ret = *s;
8217   switch(*s){
8218   case 0:
8219     break;
8220   case '|':
8221   case '(':
8222   case ')':
8223   case ';':
8224   case '&':
8225   case '<':
8226     s++;
8227     break;
8228   case '>':
8229     s++;
8230     if(*s == '>'){
8231       ret = '+';
8232       s++;
8233     }
8234     break;
8235   default:
8236     ret = 'a';
8237     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
8238       s++;
8239     break;
8240   }
8241   if(eq)
8242     *eq = s;
8243 
8244   while(s < es && strchr(whitespace, *s))
8245     s++;
8246   *ps = s;
8247   return ret;
8248 }
8249 
8250 int
8251 peek(char **ps, char *es, char *toks)
8252 {
8253   char *s;
8254 
8255   s = *ps;
8256   while(s < es && strchr(whitespace, *s))
8257     s++;
8258   *ps = s;
8259   return *s && strchr(toks, *s);
8260 }
8261 
8262 struct cmd *parseline(char**, char*);
8263 struct cmd *parsepipe(char**, char*);
8264 struct cmd *parseexec(char**, char*);
8265 struct cmd *nulterminate(struct cmd*);
8266 
8267 struct cmd*
8268 parsecmd(char *s)
8269 {
8270   char *es;
8271   struct cmd *cmd;
8272 
8273   es = s + strlen(s);
8274   cmd = parseline(&s, es);
8275   peek(&s, es, "");
8276   if(s != es){
8277     printf(2, "leftovers: %s\n", s);
8278     panic("syntax");
8279   }
8280   nulterminate(cmd);
8281   return cmd;
8282 }
8283 
8284 struct cmd*
8285 parseline(char **ps, char *es)
8286 {
8287   struct cmd *cmd;
8288 
8289   cmd = parsepipe(ps, es);
8290   while(peek(ps, es, "&")){
8291     gettoken(ps, es, 0, 0);
8292     cmd = backcmd(cmd);
8293   }
8294   if(peek(ps, es, ";")){
8295     gettoken(ps, es, 0, 0);
8296     cmd = listcmd(cmd, parseline(ps, es));
8297   }
8298   return cmd;
8299 }
8300 struct cmd*
8301 parsepipe(char **ps, char *es)
8302 {
8303   struct cmd *cmd;
8304 
8305   cmd = parseexec(ps, es);
8306   if(peek(ps, es, "|")){
8307     gettoken(ps, es, 0, 0);
8308     cmd = pipecmd(cmd, parsepipe(ps, es));
8309   }
8310   return cmd;
8311 }
8312 
8313 struct cmd*
8314 parseredirs(struct cmd *cmd, char **ps, char *es)
8315 {
8316   int tok;
8317   char *q, *eq;
8318 
8319   while(peek(ps, es, "<>")){
8320     tok = gettoken(ps, es, 0, 0);
8321     if(gettoken(ps, es, &q, &eq) != 'a')
8322       panic("missing file for redirection");
8323     switch(tok){
8324     case '<':
8325       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
8326       break;
8327     case '>':
8328       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
8329       break;
8330     case '+':  
8331       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
8332       break;
8333     }
8334   }
8335   return cmd;
8336 }
8337 
8338 
8339 
8340 
8341 
8342 
8343 
8344 
8345 
8346 
8347 
8348 
8349 
8350 struct cmd*
8351 parseblock(char **ps, char *es)
8352 {
8353   struct cmd *cmd;
8354 
8355   if(!peek(ps, es, "("))
8356     panic("parseblock");
8357   gettoken(ps, es, 0, 0);
8358   cmd = parseline(ps, es);
8359   if(!peek(ps, es, ")"))
8360     panic("syntax - missing )");
8361   gettoken(ps, es, 0, 0);
8362   cmd = parseredirs(cmd, ps, es);
8363   return cmd;
8364 }
8365 
8366 struct cmd*
8367 parseexec(char **ps, char *es)
8368 {
8369   char *q, *eq;
8370   int tok, argc;
8371   struct execcmd *cmd;
8372   struct cmd *ret;
8373 
8374   if(peek(ps, es, "("))
8375     return parseblock(ps, es);
8376 
8377   ret = execcmd();
8378   cmd = (struct execcmd*)ret;
8379 
8380   argc = 0;
8381   ret = parseredirs(ret, ps, es);
8382   while(!peek(ps, es, "|)&;")){
8383     if((tok=gettoken(ps, es, &q, &eq)) == 0)
8384       break;
8385     if(tok != 'a')
8386       panic("syntax");
8387     cmd->argv[argc] = q;
8388     cmd->eargv[argc] = eq;
8389     argc++;
8390     if(argc >= MAXARGS)
8391       panic("too many args");
8392     ret = parseredirs(ret, ps, es);
8393   }
8394   cmd->argv[argc] = 0;
8395   cmd->eargv[argc] = 0;
8396   return ret;
8397 }
8398 
8399 
8400 
8401 struct cmd*
8402 nulterminate(struct cmd *cmd)
8403 {
8404   int i;
8405   struct backcmd *bcmd;
8406   struct execcmd *ecmd;
8407   struct listcmd *lcmd;
8408   struct pipecmd *pcmd;
8409   struct redircmd *rcmd;
8410 
8411   if(cmd == 0)
8412     return 0;
8413 
8414   switch(cmd->type){
8415   case EXEC:
8416     ecmd = (struct execcmd*)cmd;
8417     for(i=0; ecmd->argv[i]; i++)
8418       *ecmd->eargv[i] = 0;
8419     break;
8420 
8421   case REDIR:
8422     rcmd = (struct redircmd*)cmd;
8423     nulterminate(rcmd->cmd);
8424     *rcmd->efile = 0;
8425     break;
8426 
8427   case PIPE:
8428     pcmd = (struct pipecmd*)cmd;
8429     nulterminate(pcmd->left);
8430     nulterminate(pcmd->right);
8431     break;
8432 
8433   case LIST:
8434     lcmd = (struct listcmd*)cmd;
8435     nulterminate(lcmd->left);
8436     nulterminate(lcmd->right);
8437     break;
8438 
8439   case BACK:
8440     bcmd = (struct backcmd*)cmd;
8441     nulterminate(bcmd->cmd);
8442     break;
8443   }
8444   return cmd;
8445 }
8446 
8447 
8448 
8449 
8450 
8451 
8452 
8453 
8454 
8455 
8456 
8457 
8458 
8459 .code16                       
8460 .globl start
8461 start:
8462   cli                         
8463 
8464   
8465   xorw    %ax,%ax             
8466   movw    %ax,%ds             
8467   movw    %ax,%es             
8468   movw    %ax,%ss             
8469 
8470   
8471   
8472 seta20.1:
8473   inb     $0x64,%al               
8474   testb   $0x2,%al
8475   jnz     seta20.1
8476 
8477   movb    $0xd1,%al               
8478   outb    %al,$0x64
8479 
8480 seta20.2:
8481   inb     $0x64,%al               
8482   testb   $0x2,%al
8483   jnz     seta20.2
8484 
8485   movb    $0xdf,%al               
8486   outb    %al,$0x60
8487 
8488   
8489   
8490   
8491   lgdt    gdtdesc
8492   movl    %cr0, %eax
8493   orl     $CR0_PE, %eax
8494   movl    %eax, %cr0
8495 
8496 
8497 
8498 
8499 
8500   
8501   
8502   
8503   ljmp    $(SEG_KCODE<<3), $start32
8504 
8505 .code32  
8506 start32:
8507   
8508   movw    $(SEG_KDATA<<3), %ax    
8509   movw    %ax, %ds                
8510   movw    %ax, %es                
8511   movw    %ax, %ss                
8512   movw    $0, %ax                 
8513   movw    %ax, %fs                
8514   movw    %ax, %gs                
8515 
8516   
8517   movl    $start, %esp
8518   call    bootmain
8519 
8520   
8521   
8522   movw    $0x8a00, %ax            
8523   movw    %ax, %dx
8524   outw    %ax, %dx
8525   movw    $0x8ae0, %ax            
8526   outw    %ax, %dx
8527 spin:
8528   jmp     spin
8529 
8530 
8531 .p2align 2                                
8532 gdt:
8533   SEG_NULLASM                             
8534   SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   
8535   SEG_ASM(STA_W, 0x0, 0xffffffff)         
8536 
8537 gdtdesc:
8538   .word   (gdtdesc - gdt - 1)             
8539   .long   gdt                             
8540 
8541 
8542 
8543 
8544 
8545 
8546 
8547 
8548 
8549 
8550 
8551 
8552 
8553 
8554 
8555 
8556 
8557 #include "types.h"
8558 #include "elf.h"
8559 #include "x86.h"
8560 #include "memlayout.h"
8561 
8562 #define SECTSIZE  512
8563 
8564 void readseg(uchar*, uint, uint);
8565 
8566 void
8567 bootmain(void)
8568 {
8569   struct elfhdr *elf;
8570   struct proghdr *ph, *eph;
8571   void (*entry)(void);
8572   uchar* pa;
8573 
8574   elf = (struct elfhdr*)0x10000;  
8575 
8576   
8577   readseg((uchar*)elf, 4096, 0);
8578 
8579   
8580   if(elf->magic != ELF_MAGIC)
8581     return;  
8582 
8583   
8584   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
8585   eph = ph + elf->phnum;
8586   for(; ph < eph; ph++){
8587     pa = (uchar*)ph->paddr;
8588     readseg(pa, ph->filesz, ph->off);
8589     if(ph->memsz > ph->filesz)
8590       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
8591   }
8592 
8593   
8594   
8595   entry = (void(*)(void))(elf->entry);
8596   entry();
8597 }
8598 
8599 
8600 void
8601 waitdisk(void)
8602 {
8603   
8604   while((inb(0x1F7) & 0xC0) != 0x40)
8605     ;
8606 }
8607 
8608 
8609 void
8610 readsect(void *dst, uint offset)
8611 {
8612   
8613   waitdisk();
8614   outb(0x1F2, 1);   
8615   outb(0x1F3, offset);
8616   outb(0x1F4, offset >> 8);
8617   outb(0x1F5, offset >> 16);
8618   outb(0x1F6, (offset >> 24) | 0xE0);
8619   outb(0x1F7, 0x20);  
8620 
8621   
8622   waitdisk();
8623   insl(0x1F0, dst, SECTSIZE/4);
8624 }
8625 
8626 
8627 
8628 void
8629 readseg(uchar* pa, uint count, uint offset)
8630 {
8631   uchar* epa;
8632 
8633   epa = pa + count;
8634 
8635   
8636   pa -= offset % SECTSIZE;
8637 
8638   
8639   offset = (offset / SECTSIZE) + 1;
8640 
8641   
8642   
8643   
8644   for(; pa < epa; pa += SECTSIZE, offset++)
8645     readsect(pa, offset);
8646 }
8647 
8648 
8649 
